:nodeCurrentVersion: v6
:npmCurrentVersion: v4
:revdate: {docdate}
:sourceDir: ./examples
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

== [ChapitreNumero]#4# Développer pour les navigateurs web

La popularité de Node s'est établie également pour la profusion d'outillage apportée au développement web _frontend_.

Ce chapitre nous apprendra le rôle de Node en tant qu'extension au développement _frontend_.

====
.Sommaire
- Gérer les dépendances externes
- Créer des interfaces réactives
- Partager du code entre Node et le navigateur
- Automatiser des tâches pénibles et répétitives
- Automatiser les tests navigateurs
====

Avant l'apparition de Node, rare était l'outillage n'imposant pas une ou plusieurs plates-formes de développement : _YUICompressor_ demandait Java, _Google Closure Compiler_ demandait Java, _sprockets_ Ruby et _pngquant_ quelques dépendances système comme _libpng_.

Leur installation n'était pas triviale.
Leur coordination encore moins.
Les adapter aux différents systèmes d'exploitation et au système d'intégration continue n'était pas non plus aisé. +
Bref c'était lourd, complexe et compliqué à moins de disposer d'une infrastructure industrialisée.

L'existence de Node et du registre _npm_ a favorisé le développement d'un écosystème orienté _frontend_.
Cela s'étend de la découverte au téléchargement des bibliothèques tierces ainsi qu'à la compilation, l'optimisation et l'exécution des tests des applications web côté client.

[TIP]
.[RemarquePreTitre]#Remarque# Versions de Node et npm
====
Le contenu de ce chapitre se réfère aux versions de *Node {nodeCurrentVersion}* et *npm {npmCurrentVersion}*.
====

toc::[]

=== Éxécuter Node dans les navigateurs web ?

Ce chapitre peut sembler confus au premier abord :
si Node s'exécute au niveau du système d'exploitation, en quoi  est-il lié au développement _frontend_ ?

Commençons par comprendre la répartition des responsabilités :

- *modules npm* : _fonctions_, _librairies_ et _outils_ prêt à l'emploi sur simple utilisation de la fonction `require()` ;
- *npm* : client permettant de télécharger et de publier des _modules npm_ afin de les consommer dans notre code applicatif ;
- *Node* : environnement d'exécution des différentes tâches et outils pour rendre les applications web digestes par les navigateurs web.

Autrement dit, *nous n'exécutons pas Node dans un navigateur web*.
Nous l'utilisons pour *assembler du code* et *le transformer* de sorte à le rendre fonctionnel dans une paire de balises `<script></script>`. +
Ce code peut être aussi bien fourni par des librairies tierces (type _jQuery_, _Angular_, _React_ etc.) que par de l'outillage (optimiseurs, suite de tests, orchestration de tâches etc.) ou encore par le code réutilisable de notre propre application web.


=== Écrire dès à présent le code du futur

Pendant longtemps, transformer du code ECMAScript ou un autre langage en ECMAScript — par exemple du code _ECMAScript 3_ en code _ECMAScript 2015_ — nécessitait l'utilisation d'un autre environnement qu'ECMAScript lui-même. +
Rhino nécessitait Java, Spidermonkey nécessitait C++ et Trident nécessitait un environnement Windows en plus de C++.

Pour autant, un projet va chambouler les règles du jeu en décembre 2011 : *esprima*.
_esprima_ est un parseur ECMAScript écrit en… ECMAScript.
Donc capable de fonctionner aussi bien dans Node que dans un navigateur web. +
Si ça n'a l'air de rien, ce projet ouvre la voie à un écosystème entier de modules qui vont faire de Node la plateforme de prédilection pour assembler ses projets _frontend_ : minifieurs plus performants, _linters_ dynamiques, mais aussi et surtout, l'avènement des *transpilateurs*.
Ces derniers compilent de l'ECMAScript (ou une surcouche d'ECMAScript) en ECMAScript interprétable par une VM ECMAScript classique.

_Coffeescript_ a été un exemple populaire de surcouche ECMAScript.
Ce langage a fortement contribué à l'émergence de fonctionnalités de la spécification _ECMAScript 2015_ : classes, fonctions fléchées, chaînes multi-lignes, destructuration etc.

On parle de _transpilation_ (ou de _compilation_) : le langage écrit est transformé dans un autre langage, compris par l'interpréteur.

La transpilation offre plusieurs avantages face à la création d'un langage compilé à part entière :

- la *versatilité des environnements d'exécution* d'_ECMAScript_ en fait un langage cible de choix ;
- la *complémentarité* avec l'écosystème ECMAScript — c'est quand même plus sympa que de devoir tout réinventer.

[TIP]
.[RemarquePreTitre]#Lien# Annonce d'esprima
====
_Aryia Hidayat_ introduit exprima dans un billet de blog.
Il y présente notamment des comparatifs de performances d'exécution sur différentes VM ECMAScript et face à d'autres parseurs.

- [URL]#https://ariya.io/2011/12/introducing-esprima#
====

==== L'approche traditionnelle du dénominateur commun

[[transpilation]]
==== Écrire au plus proche des standards

TBD.


[TIP]
.[RemarquePreTitre]#Histoire# Traceur
====

_Traceur_ est un des premiers transpilateurs _ECMAScript 2015_ vers _ECMAScript 5_ à avoir émergé dans l'écosystème Node.

Il a permis de commencer à *écrire des modules en _ECMAScript 2015 bien avant que la spécification ne soit entièrement terminée*.
Et donc de pouvoir anticiper son apprentissage tout en mettant le langage à l'épreuve avant sa finalisation.
====

[[polyfills]]
==== Combler les manques avec des _polyfills_

TBD.


[[typescript]]
==== Écrire dans un autre langage : l'exemple TypeScript

TBD.

=== Une conception orientée composant

TBD.

==== Le syndrôme du plugin jQuery

TBD.

==== Vers une approche jQuery composite

TBD.

==== Partager le code métier avec Node

TBD.

==== Séparation du fond et de la forme : données, rendu et interactions

TBD.

==== Rapprocher présentation et interactions avec React

TBD.

==== Lier composants et feuilles de style

TBD.

[[io]]
=== Des requêtes AJAX au temps-réel

TBD.

[[io-fetch]]
==== Consommer des données hétérogènes avec `fetch()`

TBD.

[[io-sse]]
==== Approche unidirectionnelle avec _Server Sent Events_

TBD.

[[io-websockets]]
==== Échanges en temps-réel avec _Websockets_

TBD.


=== Tester son code


==== Écrire des tests avec tape et chai

TBD.

==== Exécuter les suites de tests avec Karma

TBD.

==== Tester les éléments de lisibilité et de performance

TBD.

==== Tester la compatibilité navigateurs avec BrowserStack

TBD.

==== Le cas Internet Explorer et ievms

TBD.

=== Conclusion

TBD.
