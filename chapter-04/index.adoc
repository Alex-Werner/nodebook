:nodeCurrentVersion: v6
:npmCurrentVersion: v4
:revdate: {docdate}
:sourceDir: ./examples
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

== [ChapitreNumero]#4# Développer pour les navigateurs web

Les chapitres précédents ont démontré l'utilité de Node pour la création de modules réutilisables ainsi que pour le développement d'applications et d'utilitaires.

Ce chapitre nous apprendra le rôle de Node pour le développement _frontend_ et la réalisation d'applications web.

====
.Sommaire
- Gérer les dépendances externes
- Créer des interfaces réactives
- Partager du code entre Node et le navigateur
- Automatiser des tâches pénibles et répétitives
- Automatiser les tests navigateurs
====

Avant l'apparition de Node, rare était l'outillage n'imposant pas une plateforme entière de développement.
Il faut se contenter de programmes tels que _YUICompressor_, _Google Closure Compiler_, _sprockets_ ou encore _pngquant_.
Leur utilisation requiert des dépendances variées comme Ruby, Java ou des librairies, parfois incompatibles entre elles et dont la procédure d'installation diffère selon les systèmes d'exploitation — lorsqu'ils sont multi-plateformes.
C'est sans parler des difficultés d'intégration et de leur systématisation au sein des projets.

Bref c'était lourd, complexe et compliqué à moins de disposer d'une infrastructure industrialisée. +
L'existence de Node a favorisé le développement d'un écosystème entier d'outillage et ce, de la découverte et le téléchargement des bibliothèques tierces à la compilation, à la phase d'optimisation et à l'exécution des tests de vos composants et applications web.

[TIP]
.[RemarquePreTitre]#Remarque# Versions de Node et npm
====
Le contenu de ce chapitre se réfère aux versions de *Node {nodeCurrentVersion}* et *npm {npmCurrentVersion}*.
====

toc::[]

=== Éxécuter Node dans les navigateurs web ?

Ce chapitre peut sembler confus au premier abord :
si Node s'exécute au niveau du système d'exploitation, en quoi  est-il lié au développement _frontend_ ?

Commençons par comprendre la répartition des responsabilités :

- *modules npm* : _fonctions_, _librairies_ et _outils_ prêt à l'emploi sur simple utilisation de la fonction `require()` ;
- *npm* : client permettant de télécharger et de publier des _modules npm_ afin de les consommer dans notre code applicatif ;
- *Node* : environnement d'exécution des différentes tâches et outils pour rendre les applications web digestes par les navigateurs web.

Autrement dit, *nous n'exécutons pas Node dans un navigateur web*.
Nous l'utilisons pour *assembler du code* et *le transformer* de sorte à le rendre fonctionnel dans une paire de balises `<script></script>`. +
Ce code peut être aussi bien fourni par des librairies tierces (type _jQuery_, _Angular_, _React_ etc.) que par de l'outillage (optimiseurs, suite de tests, orchestration de tâches etc.) ou encore par le code réutilisable de notre propre application web.


=== Écrire dès à présent le code du futur

Pendant longtemps, transformer du code ECMAScript ou un autre langage en ECMAScript — par exemple du code _ECMAScript 3_ en code _ECMAScript 2015_ — nécessitait l'utilisation d'un autre environnement qu'ECMAScript lui-même. +
Rhino nécessitait Java, Spidermonkey nécessitait C++ et Trident nécessitait un environnement Windows en plus de C++.

Pour autant, un projet va chambouler les règles du jeu en décembre 2011 : *esprima*.
_esprima_ est un parseur ECMAScript écrit en… ECMAScript.
Donc capable de fonctionner aussi bien dans Node que dans un navigateur web. +
Si ça n'a l'air de rien, ce projet ouvre la voie à un écosystème entier de modules qui vont faire de Node la plateforme de prédilection pour assembler ses projets _frontend_ : minifieurs plus performants, _linters_ dynamiques, mais aussi et surtout, l'avènement des *transpilateurs*.
Ces derniers compilent de l'ECMAScript (ou une surcouche d'ECMAScript) en ECMAScript interprétable par une VM ECMAScript classique.

_Coffeescript_ a été un exemple populaire de surcouche ECMAScript.
Ce langage a fortement contribué à l'émergence de fonctionnalités de la spécification _ECMAScript 2015_ : classes, fonctions fléchées, chaînes multi-lignes, destructuration etc.

On parle de _transpilation_ (ou de _compilation_) : le langage écrit est transformé dans un autre langage, compris par l'interpréteur.

La transpilation offre plusieurs avantages face à la création d'un langage compilé à part entière :

- la *versatilité des environnements d'exécution* d'_ECMAScript_ en fait un langage cible de choix ;
- la *complémentarité* avec l'écosystème ECMAScript — c'est quand même plus sympa que de devoir tout réinventer.

[TIP]
.[RemarquePreTitre]#Lien# Annonce d'esprima
====
_Aryia Hidayat_ introduit exprima dans un billet de blog.
Il y présente notamment des comparatifs de performances d'exécution sur différentes VM ECMAScript et face à d'autres parseurs.

- [URL]#https://ariya.io/2011/12/introducing-esprima#
====

==== L'approche traditionnelle du dénominateur commun

[[transpilation]]
==== Écrire au plus proche des standards

TBD.


[TIP]
.[RemarquePreTitre]#Histoire# Traceur
====

_Traceur_ est un des premiers transpilateurs _ECMAScript 2015_ vers _ECMAScript 5_ à avoir émergé dans l'écosystème Node.

Il a permis de commencer à *écrire des modules en _ECMAScript 2015 bien avant que la spécification ne soit entièrement terminée*.
Et donc de pouvoir anticiper son apprentissage tout en mettant le langage à l'épreuve avant sa finalisation.
====

[[polyfills]]
==== Combler les manques avec des _polyfills_

TBD.


[[typescript]]
==== Écrire dans un autre langage : l'exemple TypeScript

TBD.

=== Une conception orientée composant

TBD.

==== Le syndrôme du plugin jQuery

TBD.

==== Vers une approche jQuery composite

TBD.

==== Partager le code métier avec Node

TBD.

==== Séparation du fond et de la forme : données, rendu et interactions

TBD.

==== Rapprocher présentation et interactions avec React

TBD.

==== Lier composants et feuilles de style

TBD.

[[io]]
=== Des requêtes AJAX au temps-réel

TBD.

[[io-fetch]]
==== Consommer des données hétérogènes avec `fetch()`

TBD.

[[io-sse]]
==== Approche unidirectionnelle avec _Server Sent Events_

TBD.

[[io-websockets]]
==== Échanges en temps-réel avec _Websockets_

TBD.


=== Tester son code


==== Écrire des tests avec tape et chai

TBD.

==== Exécuter les suites de tests avec Karma

TBD.

==== Tester les éléments de lisibilité et de performance

TBD.

==== Tester la compatibilité navigateurs avec BrowserStack

TBD.

==== Le cas Internet Explorer et ievms

TBD.

=== Conclusion

TBD.
