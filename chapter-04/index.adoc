:nodeCurrentVersion: v4
:npmCurrentVersion: v3
:revisionYear: 2015
:sourceDir: ./examples/src
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

== [ChapitreNumero]#4# Au service du développement frontend

Les chapitres précédents ont démontré l'utilité de Node pour la création de modules réutilisables ainsi que pour le développement d'applications et d'utilitaires.

Ce chapitre nous apprendra le _rôle utilitaire_ de Node pour le développement _frontend_.
C'est à dire l'utilisation de Node comme outil de productivité et d'automatisation du développement de composants Web.

====
.Sommaire
- Choisir un gestionnaire de paquets
- Un outillage sur mesure
- Automatiser les projets
- Partager du code entre Node et le navigateur
- Tester dans le navigateur
====

Node en tant que plate-forme ne fournit rien de spécial à part des fondations communes avec les navigateurs Web.
C'est la richesse et la versatilité de l'écosystème npm qui nous permet de mieux outiller nos projets.

Pour rappel, avant l'apparition de Node, rare était l'outillage n'imposant pas une plateforme de développement entière (comme _sprockets_ et _assetic_ dans les univers Ruby et PHP).
Il fallait se contenter de programmes tels que _YUICompressor_, _Google Closure Compiler_ ou encore _pngquant_.
Leur installation diffère selon les systèmes d'exploitation, quand ils sont multi-plateformes.
C'est sans parler de leur intégration et de leur systématisation au sein des projets.

Bref c'était lourd et compliqué à moins de disposer d'une infrastructure industrialisée. +
Node simplifie tout, de la récupération des bibliothèques tierces à la compilation, optimisation et aux tests de vos composants Web.

[TIP]
.[RemarquePreTitre]#Remarque# Versions de Node et npm
====
Le contenu de ce chapitre se réfère aux versions de *Node {nodeCurrentVersion}* et *npm {npmCurrentVersion}*.
====

toc::[]

=== Gestion des dépendances

Avant Node, l'obtention d'une bibliothèque se faisait en allant sur son site web respectif puis en téléchargeant une archive avant de la décompresser dans votre répertoire de travail.
C'est sans compter sur les téléchargements sur-mesure dont il fallait mémoriser les options de mise à jour en mise à jour.

Tout ceci appartient au passé grâce aux gestionnaires de paquets.
Ils rendent explicites la liste des dépendances, le spectre des versions compatibles ainsi que l'automatisation des opérations d'installation et de mises à jour.

==== npm

_npm_ est le gestionnaire de dépendances inclus dans les distributions courantes de Node.
Pourquoi en parler s'il ne fonctionne que pour Node ?
Car contrairement aux à prioris, *npm ne se limite pas à la gestion des dépendances spécifiques à Node*.
npm utilise Node comme moteur d'exécution mais vous pouvez tout  fait empaqueter des images, fichiers CSS, Sass, <<typescript,TypeScript>> etc.

Quelles sont les raisons de choisir npm comme gestionnaire de dépendances _frontend_ ?

- *déclaration explicite* des points d'entrée via la propriété _main_ du fichier _package.json_ ;
- gestion des dépendances de dépendances et quasi-absence de conflits de version ;
- outillage et *écosystème riche* et complet ;
- transformation des appels _CommonJS_ en modules _ECMAScript 2015_ et vice-versa via des transpilateurs ou _transforms_ ;
- c'est le meilleur moyen d'*atteindre l'_isomorphisme applicatif_* (lire <<universal-applications,Vers un code universel et modulaire>> dans ce même chapitre).

L'exemple suivant illustre plusieurs moyens d'inclure jQuery dans une page HTML, via une simple balise script, via un module _CommonJS_ (syntaxe Node) ou via la syntaxe des _modules_ d'ECMAScript 2015 :

[source,html]
.snippets/dependency-npm.html
----
include::{sourceDir}/snippets/dependency-npm.html[]
----

L'utilisation de modules _CommonJS_ nécessitera une étape de compilation avant de pouvoir fonctionner nativement dans le navigateur.
C'est quelque chose que nous adresserons dans la section <<automation, automatisation des tâches>> de ce même chapitre.

L'étape de compilation sera également nécessaire si les navigateurs cibles de votre applications ne sont pas compatibles nativement avec les _modules ECMAScript 2015_. +
Pour cela nous aurons recours à un _transpilateur_, pour convertir du code ECMAScript 2015 en ECMAScript 5.
Nous en reparlerons dans la section <<transpilation,Transpilation>> de ce même chapitre.

Certains auteurs de paquets _npm_ proposent du code préalablement compilé et prêt à l'emploi, en général et par convention dans un répertoire `dist/`.

_npm_ organise les dépendances selon une structure dite _plate_ (_flat tree structure_).
Ainsi, si deux modules distincts se basent sur une *version compatible d'une même dépendance* selon _semver_ — ici, jQuery v2 —  voici l'arbre de dépendance de _npm_ et la disposition sur le système de fichiers qui en résultent :

----
$ npm ls
my-app@1.0.0
├── module-a@1.0.0
|   └── jquery@2.1.0
└── module-b@1.0.0
    └── jquery@2.1.4

$ tree node_modules
node_modules
├── jquery
├── module-a
└── module-b
----

Dans le cas où plusieurs modules dépendant d'un même paquet mais dans une version _semver_ incompatible — ici jQuery v1 et jQuery v2 — la version la plus _ancienne_ se trouvera à la racine du répertoire _node_modules_ tandis que les autres seront _encapsulées_ au plus près du module en dépendant :

----
$ npm ls
my-app@1.0.0
├── module-a@1.0.0
|   └── jquery@1.11.3
└── module-b@1.0.0
    └── jquery@2.1.4

$ tree node_modules
node_modules
├── jquery
├── module-a
└── module-b
    └── jquery
----

L'utilisation de `npm dedupe` peut être un ultime recours pour optimiser un arbre plus complexe que celui-ci.
Ceci dans l'optique de diminuer les inclusions multiples d'une librairie techniquement compatible avec d'autres versions mineures.

[CAUTION]
.[RemarquePreTitre]#Remarque# Résolution de chemins
====
Il est fortement *déconseillé de se baser sur des chemins en dur* tapant dans le répertoire _node_modules_.
Il est *préférable de faire appel à `require.resolve`* pour déterminer le chemin vers un fichier compris dans une dépendance.

[source,javascript]
----
// À ne surtout pas faire
var jqueryCore = require('./node_modules/jquery/src/core.js');

// À faire
var jQueryCore = require('jquery/src/core.js');
----
====

Nous verrons davantage d'exemples, plus complets et tendant vers une même base de code compatible à la fois avec les API de Node et des navigateurs Web dans la section <<universal-applications, Vers un code universel et modulaire>>.

==== bower

_bower_ est un gestionnaire de dépendances entièrement dédié aux composants _frontend_.
Son interface est très proche de celle la commande npm.
Les dépendances sont quant à elles listées dans un fichier `bower.json`, lui-même très similaire au fichier `package.json`.

Ce projet a rencontré une forte popularité à une époque où les développeurs pensaient que _npm_ était dédié uniquement à Node et de ce fait, que _npm_ n'était pas adapté à la gestion des dépendances _front-end_.

Toutefois je *déconseille d'utiliser _bower_* pour les raisons suivantes :

- les fonctionnalités sont identiques à peu de chose près à celles de _npm_ ;
- vous aurez la plupart besoin d'un peu d'outillage complémentaire via _npm_, donc autant n'utiliser qu'un seul outil ;
- _bower_ ne sait pas gérer la présence d'un même module dans deux versions conflictuelles — ce qui représente un frein aux installations automatisées ;
- les composants _bower_ ne peuvent être employées pour la création d'<<universal-applications,applications universelles>>.

_bower_ dispose d'un seul avantage : la capacité à collecter des  librairies qui ne sont pas déclarées dans un registre.
Cela peut se révéler pratique pour l'inclusion de code tiers assez ancien.

==== Exposer un composant web avec Node

Il peut arriver que vous ayiez besoin de servir certaines ressources de modules via HTTP sans utiliser de préprocesseur ou d'outil de compilation.

Le _framework_ _express_ ([URL]#http://expressjs.com/#) met à disposition un mécanisme de _montage d'URL_.
En combinant ce mécanisme avec la méthode `express.static`, il devient alors possible d'exposer n'importe quel fichier inclut dans _npm_modules_ (ou autre répertoire) en tant que ressource Web.

[source,javascript]
.snippets/npm-express.js
----
include::{sourceDir}/snippets/npm-express.js[]
----
<1> Rend accessible le fichier `jquery.js` à l'adresse `http://localhost:3000/assets/jquery.js` ;
<2> Rend accessible le répertoire `node_modules` à l'adresse `http://localhost:3000/assets`, et donc d'une autre manière, le fichier `jquery.js` à l'adresse `http://localhost:3000/assets/jquery/dist/jquery.js`.

=== Un outillage sur mesure

Qu'il s'agisse de vos propres composants ou de modules tiers, l'écosystème Node regorge d'utilitaires facilitant la vie de tout développeur _frontend_.

Outre l'uniformisation de l'installation de vos composants et dépendances, *vous rendez explicite et partagez le même processus* avec tous les membres de votre équipe.
Et même si vous êtes seul(e) sur le projet, vous construisez une documentation d'utilisation pour les prochaines personnes susceptibles de participer au projet.

Autre avantage indéniable : l'ubiquité des utilitaires.
S'ils peuvent être utilisés de manière indépendante, ils s'intègrent très bien avec des outils d'automatisation ou des _frameworks_ populaires.

Vous trouverez ci-après une suggestion non-exhaustive de modules utiles à tout développeur _frontend_.

==== Vérification syntaxique

La vérification syntaxique est un mécanisme s'assurant que votre code respecte la grammaire du langage associé.
Elle peut autant révéler des anomalies fondamentales (balise mal fermée, expression inconnue etc.) que renforcer des pratiques de programmation réduisant les erreurs potentielles lors de l'exécution du-dit code.

Il s'agit d'une excellente première étape avant d'introduire des tests unitaires ou fonctionnels.
C'est aussi une pratique rapide à mettre en œuvre — de préférence dès le début du projet — et poussant à harmoniser les pratiques de développement au sein d'un group d'individus.

Les modules à disposition dans npm vous permettront de couvrir vos fichiers CSS, HTML et ECMAScript bien sûr !

*htmlhint* ([URL]#https://npmjs.com/htmlhint#) est un outil en ligne de commande vérifiant la structure de vos documents HTML.
Il rapporte les doublons d'attributs `id`, la présence de paires de balises mal formées, l'absence de balise fermante ou encore l'existance de chaînes de caractère non-imprimables dans des attributs critiques, entre autre.

Prenons en exemple le document suivant :

[source,html]
.snippets/sample.html
----
include::{sourceDir}/snippets/sample.html[]
----

Une lecture distraite pourrait nous faire passer à côté des erreurs mais également des inconsistances de programmation.
Sur un document plus réaliste, et donc volumineux, avec de fréquents changements, autant oublier la vérification manuelle.

L'exécution de *htmlhint* avec ses règles par défaut remontera les alertes suivantes :

----
$ npm run lint-html
src/snippets/sample.html:
line 1, col 1: Doctype must be first.
line 8, col 10: Id redefinition of [ btn ].
line 10, col 3: Tagname [ BUTTON ] must be lower case.
line 10, col 10: The value of attribute [ class ] must closed by double quotes.
line 10, col 52: Tagname [ BUTTON ] must be lower case.
----

Si elle peuvent paraître opiniatres, sachez qu'elles n'ont pour seul but que de décider une bonne fois pour toute quelle attitude adopter : tout ou rien en miniscule, guillemets simples ou doubles, doctype explicite etc.

*eslint* ([URL]#https://npmjs.com/eslint#) est l'outil de vérification syntaxique pour ECMAScript le plus *complet et modulaire*.
Il offre un niveau de souplesse extrême au niveau de la configuration des règles à appliquer (utilisation systématique de `use strict`, nombre maximum de paramètres de fonctions, objets non-déclarés, variables inconnues etc.). +
Il expose également une API relativement simple afin de créer vos propres règles métier.
Un autre mécanisme permet d'inclure et d'étendre un ou plusieurs  fichiers de configuration afin de les réutiliser dans différents projets.

[TIP]
.[RemarquePreTitre]#Bon à savoir# Règles par défaut
====
*eslint* n'applique aucune règle par défaut.
Ses premières utilisations nécessiteront donc de prendre connaissance des règles à disposition … ou d'opter pour un module _npm_ définissant une configuration _à votre goût_.

En effet si certaines règles nous alertent de dangers potentiels, d'autres sont totalement subjectives et sujettes à des préférences purement personnelles.
====

*eslint* lit la section `eslintConfig` du fichier `package.json` pour adapter son comportement. +
 
L'exemple suivant illustre une configuration d'_eslint_ renforçant la déclaration du mode strict au niveau global, l'emploi des égalités strictes, l'interdiction de l'utilisation de variables non déclarées, la cohérence d'utilisation des accolades ainsi que l'utilisation de guillemets simples uniquement :

[source,json]
.package.json
----
include::{sourceDir}/../package-eslint.json[]
----

Le niveau de sévérité de chaque règle peut être configuré à l'aide d'un nombre entier :

- `0` : règle désactivée ;
- `1` : affiche un avertissement ;
- `2` : affiche une erreur (le processus se terminera avec un code d'erreur).

Certaines règles demandent ou acceptent des arguments supplémentaires.
Ces arguments sont documentés dans le répertoire `lib/rules` de la bibliothèque _eslint_ ainsi que sur le site Web du projet ([URL]#http://eslint.org/docs/rules/#).

*csslint* ([URL]#https://npmjs.com/csslint#) est un outil de vérification syntaxique de feuilles de style CSS.
Il a été créé par deux anciens ingénieurs de _Yahoo!_.
Leurs anciens travaux dans le domaine de la performance ont influencé l'architecture et le choix des règles par défaut.
Celles-ci peuvent d'ailleurs être étendues, moins aisément que pour *eslint* certes, mais suffisamment pour adapter l'outil aux besoins modernes, notamment ceux du web mobile.

*csslint* fournit les mécanismes de vérification adéquats pour alerter de possibles effets de bord de _box model_, de déclaration incompatible de `@font-face`, de _vendor prefix_ dépréciés (voir plus loin la section _Optimisation du code_) ou encore de combinaisons de propriétés connues pour casser l'affichage dans certains navigateurs.

Prenons par exemple le fichier CSS suivant :

[source,css]
.snippets/sample.css
----
include::{sourceDir}/snippets/sample.css[]
----

*csslint* génèrera trois alertes en lisant le fichier `sample.css` et ce, même si celui-ci est syntaxiquement parfaitement valide :

----
$ csslint src/snippets/sample.css

csslint: There are 3 problems in snippets/sample.css.

sample.css
1: warning at line 4, col 11
Values of 0 shouldn't have units specified.
  border: 0px solid black;

sample.css
2: warning at line 4, col 3
Using height with border can sometimes make elements larger than you expect.
  border: 0px solid black;

sample.css
3: warning at line 6, col 3
Using height with padding can sometimes make elements larger than you expect.
  padding: 10px;
----

Si la présence d'une mesure en pixels n'est qu'une affaire de micro-optimisation, les deux autres erreurs sont nettement plus problématiques car elles impliquent un manque de consistance d'affichage, selon le navigateur effectuant le rendu. +
Éviter l'utilisation de ces cas limites évite également d'avoir à empiler des couches de CSS pouvant accentuer encore peu plus l'instabilité d'affichage.


*doiuse* ([URL]#https://npmjs.com/doiuse#) est un utilitaire qui se repose sur la base de données de [URL]#caniuse.com#.
Il vous alerte des possibles incompatibilités de syntaxe en fonction de la compatibilité désirée avec une liste de navigateurs web définie par vos soins.
Cette liste peut aussi bien concerner des versions spécifiques ou encore cibler en fonction leurs parts de marché.

L'exemple suivant illustre les alertes relevées par _doiuse_ dans le cas d'une recherche de compatibilité avec Internet Explorer 6 et Internet Explorer 7 :

----
$ doiuse -b 'ie < 8' src/snippets/sample.css
src/snippets/sample.css:1:1: CSS 2.1 selectors not supported by: IE (6)
src/snippets/sample.css:8:1: CSS 2.1 selectors not supported by: IE (6)
src/snippets/sample.css:12:1: CSS3 Transitions not supported by: IE (6,7)
src/snippets/sample.css:14:1: CSS 2.1 selectors not supported by: IE (6)
----


==== Minification du code

Commentaires, indentations ou encore noms de variables : tout ça occupe de la place, donc des caractères textuels et donc des octets de bande passante.

Sans outillage, l'optimisation repose littéralement entre les mains des développeurs.
Ces derniers doivent alors compromettre lisibilité et maintenabilité au profit de quelques kilo-octets. +
Ce que nous chercherons à tout prix à ne pas sacrifier.

Les minifieurs mettent en œuvre différentes techniques pour réduire cette occupation d'espace :

- suppression des commentaires et caractères non-significatifs ;
- renommage de variables ;
- factorisation d'occurences multiples similaires ;
- suppression des instructions relatives au débogage/développement ;
- suppression de code mort.

Ces différentes techniques de minification chercherons à préserver l'intégrité du fonctionnement ou de l'apparence de vos programmes.
Un avertissement vous préviendra du contraire le cas échéant.

*cssmin* ([URL]#https://npmjs.com/cssmin#) est un portage ECMAScript du compresseur CSS _YUICompressor_ développé par la compagnie _Yahoo!_ à la fin des années 2000. +
L'approche de *cssmin* consiste principalement à supprimer les caractères et commentaires non-significatifs.
Il ne cherche pas à faire davantage que son homologue originel.

*cssmin* est donc un outil simple, exposant un exécutable système ainsi qu'un module Node.
Il ne fournit en revanche aucun support pour les _Source Maps_. Il vous faudra reposer sur l'outillage proposé par les navigateurs Web modernes pour le débogage (reformatage du code, inspection des propriétés etc.).

.Exemples d'utilisation de *cssmin*
----
cssmin src/snippets/sample.css > sample.min.css # <1>

cat src/snippets/sample.css | cssmin | wc -c | awk '{print $1}' # <2>
----
<1> Exporte le résultat de la minification dans le fichier `sample.min.css`; 
<2> Utilisation des *pipes* UNIX pour afficher le nombre de caractères d'une version minifiée de `sample.css`.

**UglifyJS** ([URL]#https://npmjs.com/uglify-js2#) est un des premiers compresseurs à utiliser une  représentation syntaxique en arbre (_Abstract Syntax Tree_ — _AST_) en lieu et place des classiques optimisations à coups d'expressions régulières.

Cette méthode permet d'élargir les perspectives de la compression via de la réécriture de code :

- _hoisting_ des variables (remontée de leur déclaration en début de _scope_) ;
- combinaison des déclarations de variables ;
- factorisation des valeurs de variables ;
- réécriture partielle d'expressions ;
- injection en ligne du contenu de variables.

*UglifyJS* s'utilise de manière autonome, en ligne de commande ou via son API ECMAScript, mais aussi par le biais de plugins grunt, gulp et <<browserify,browserify>> (uglifyify et minifyify). +
Un exemple plus concret est abordé dans la section <<automation,automatisation des tâches>> de ce même chapitre.

==== Optimisation du code

Parce qu'optimiser le poids ne suffit pas, certains outils et compresseurs proposent de réécrire une partie de votre code.
Ces optimisations seraient souvent complexes à imaginer et couteuses en temps, à répéter le geste et en maintenance.

La majorité des optimiseurs suggérés vous inciteront à suivre la voie des standards.
Vous écrivez du code orienté vers le long terme et les outils se chargent du fardeau de la compatibilité avec le quotidien. +
De ce fait, ils ajouteront des instructions relatives à une plus grande compatibilité ou à l'inverse, ils retireront des portions inutilisées.

Quoiqu'il advienne, en complément des compresseurs ou non, votre code source d'origine reste intact.
Il est d'autant plus aisé de les tester, de les activer et de les désactiver quand bon vous semble.

*autoprefixer* ([URL]#https://npmjs.com/autoprefixer#) est _le_ module qui vous épargnera l'écriture de centaines de lignes en ajoutant automatiquement les bons préfixes aux bons endroits. 
Travail d'autant plus ingrat si vous n'avez pas envie ni le loisir de recourir à des _mixins_ Less ou Sass. +
_autoprefixer_ expose une API ECMAScript, un exécutable système ainsi qu'une API de _streaming_ permettant une intégration sans plugin avec <<browserify,browserify>>, entre autre.

.Exemple d'utilisation d'_autoprefixer_ en fonction des besoins en compatibilité navigateur
----
$ autoprefixer -o - src/snippets/sample.css | grep transition
  -webkit-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;
          
$ autoprefixer -b 'firefox > 8' -o - src/snippets/sample.css | grep transition
  -webkit-transition: font-weight 0.2s ease;
     -moz-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;
----

L'exemple précédent illustre comment la propriété `transition` a été préfixée pour couvrir les navigateurs ayant plus de 1% de part de marché, puis en incluant les versions supérieures à Firefox 8 — assez obsolètes il faut se l'avouer. +
L'utilisation du paramètre `-o -` (_o_ pour _output_) suivi du caractère _trait d'union_ redirige le code réécrit en _sortie standard_ au lieu de modifier le fichier originel.

*uncss* ([URL]#https://npmjs.com/uncss#) est le pendant inverse d'_autoprefixer_ puisqu'il se charge de supprimer le code … mort.
Pour se faire, _uncss_ charge une ou plusieurs pages de référence et fait la différence entre les règles CSS utilisées … et celles qui ne le sont pas.
Libre à vous de mentionner une liste blanche de règles à ne jamais supprimer pour éviter qu'elles soient écrémées par mégarde.+
_uncss_ s'intègre particulièrement facilement dans les projet grâces à des plugins _grunt_ et <<gulp, gulp>>.

Si le monde de l'optimisation ECMAScript a explosé depuis l'apparition d'*esprima*, il en est de même pour CSS avec *PostCSS* ([URL]#https://npmjs.com/postcss#). +
Cet outil est construit autour du triptyque suivant :

- un parseur CSS ;
- un arbre syntaxique ;
- un compilateur texte.

Cette combinaison rend possible la production de _Source Maps_ mais aussi la construction d'une multitude d'outils destinés à faciliter la vie des développeurs.
Ces outils se greffent sur le parseur, l'arbre ou le compilateur pour parvenir à leurs fins. +
Avec une ou plusieurs extensions, vous avez ainsi accès à *autoprefixer*, à votre nettoyeur de code mort ou même à votre propre réimplémentation de Sass … entièrement en ECMAScript !

Enfin, il est bon de savoir que d'autres outils existent, complètent voire remplacent les compresseurs et optimiseurs précédemment cités :

- *Google Closure Compiler* ([URL]#https://npmjs.com/closurecompiler#) +
Un autre compilateur ECMAScript plus poussé qu'_UglifyJS_ mais imposant un style d'écriture plus strict, voire plus contraignant selon votre style d'écriture.
- *csswring* ([URL]#https://npmjs.com/csswring#) +
Une alternative plus moderne que _cssmin_.
Cet outil s'interface optionnellement avec _PostCSS_ et offre un support des _Source Maps_.
- *csso* ([URL]#https://npmjs.com/csso#) +
Une autre alternative à _cssmin_ et _csswring_ écrite par l'équipe derrière la méthodologie BEM ([URL]#https://en.bem.info#), moins bien documentée mais plus efficace en terme d'optimisations.
_csso_ ira jusqu'à réécrire les codes couleurs, les `margin` et `padding` et factorisera les sélecteurs similaires.

==== Optimisation des images

- génération de sprites
- réduction du poid des fichiers
- génération de vignettes
- SVG https://www.npmjs.com/svgo

==== Optimisation des fontes

- optimisation des chemins
- iconfontes
- https://npmjs.com/connect-fonts

==== Livereload

- watcher
- livereload
- HMR (Hot Module Replacement)

[[transpilation]]
=== Transpilation

Pendant longtemps, transformer de l'ECMAScript en ECMAScript — par exemple de l'ES5 en ES3 ou un autre langage en ECMAScript nécessitait l'utilisation d'un autre environnement qu'ECMAScript lui-même. +
Rhino nécessitait Java, Spidermonkey nécessitait C++ et Trident nécessitait un environnement Windows en plus de C++.
Même Node et V8 requièrent C++ pour interpréter de l'ECMAScript.

Pour autant, un projet va chambouler les règles du jeu en décembre 2011 : *esprima*.
_esprima_ est un parseur ECMAScript écrit en… ECMAScript.
Donc capable de fonctionner aussi bien dans Node que dans un navigateur Web. +
Si ça n'a l'air de rien, ce projet ouvre la voie à un écosystème entier de modules qui vont faire de Node la plateforme de prédilection pour assembler ses projets _frontend_ : minifieurs plus performants, _linters_ dynamiques, mais aussi et surtout, l'avènement des *transpilateurs*.
Ces derniers compilent de l'ECMAScript (ou une surcouche d'ECMAScript) en ECMAScript interprétable par une VM ECMAScript classique.  

_Coffeescript_ est un exemple populaire de surcouche ECMAScript.
Ce langage a fortement contribué à transvaser nombre de ses fonctionnalités vers la spécification ECMAScript 6 : classes, fonctions fléchées, chaînes multi-lignes, destructuration etc.

On parle de _transpilation_ et non de _compilation_ car le processus de transformation traduit un langage en un autre langage qui n'est pas un langage machine.
On compile un certain langage en ECMAScript qui nécessite une VM ECMAScript pour que les instructions soient enfin traduites en opérations CPU.

[WARNING]
.[RemarquePreTitre]#Attention# Coffeescript ou pas Coffeescript ?
====
Il n'est pas recommandé d'utiliser _Coffescript_ sur de nouveaux projets depuis la sortie d'ECMAScript 2015.

Si vous souhaitez un langage davantage typée qu'ESCMAScript, je vous recommande de vous pencher sur <<typescript,TypeScript>>.
====

La transpilation offre plusieurs avantages face à la création d'un langage compilé à part entière :

- le code transpilé est un *artéfact durable* — souvent lisible et modifiable par un humain — qui permet éventuellement de se passer du langage transpilé initial ;
- la *complémentarité* avec l'écosystème ECMAScript — c'est quand même plus sympa que de devoir tout réinventer ;
- l'orientation vers des *langages davantage maintenables* bénéficiant à terme à la spécification ECMAScript.

La suite de cette section s'intéressera à des transpilateurs modernes et singuliers pour vous aider à vous faire une idée de leur utilité au sein d'un projet Web géré seul, en équipe ou en communauté.

[TIP]
.[RemarquePreTitre]#Lien# Annonce d'esprima
====
_Aryia Hidayat_ introduit exprima dans un billet de blog.
Il y présente notamment des comparatifs de performances d'exécution sur différentes VM ECMAScript et face à d'autres parseurs. 

- [URL]#http://ariya.ofilabs.com/2011/12/introducing-esprima.html#
====

==== Traceur

_Traceur_ est un des premiers transpilateurs ES6 vers ES5 à avoir émergé dans l'écosystème Node.
Il est le fruit d'ingénieurs de *Google*.

L'avantage de _traceur_ ?
Avoir permis d'*écrire des modules en ES6 avant que la spécification ne soit entièrement terminée*.
Et donc de pouvoir anticiper son apprentissage tout en mettant le langage à l'épreuve avant sa finalisation.

Il a depuis été dépassé en terme d'intégration, de modularité et de complétion d'implémentation de fonctionnalités ES6 par <<babel,Babel>> (voir ci-après).

[[babel]]
==== Babel

TBD.

[[typescript]]
==== TypeScript

TBD.

==== Publication sur npm

Répondre aux questions :

- quels impacts si on publie uniquement les sources d'un module non-interprétable directement par Node
- comment faire pour publier ? Et pour tester ?


[[universal-applications]]
=== Vers un code universel et modulaire

Le concept d'*applications universelles* (parfois appelées _applications isomorphiques_) a été sur toutes les bouches en 2015.

Imaginez une application où la logique de routage des requêtes HTTP (_routing_), les modèles de données et le rendu HTML ne sont écrits qu'une seule fois.
Imaginez que ces composants soient fonctionnels du côté de vos serveur ainsi que dans les navigateurs Web accédant à votre service en ligne.

Beaucoup y voient un moyen d'enfin développer des applications web monopages (_single page apps_) rapides et accessibles — souvenez-vous de l'époque des sites entièrement développés en Flash.

On peut ainsi *combiner* l'approche web _classique_ et des _interfaces dynamiques_ sans pour autant imposer une page blanche en attendant que les centaines de kilo-octets (voire de méga-octets) de la base de code ECMAScript de votre application soit transférée sur le réseau puis interprétée par le navigateur. +
C'est sans parler des performances réseau et de puissance de calcul plus réduites sur mobile.

Malheureusement et comme souvent, beaucoup y ont également vu une méthode pour développer _toutes_ les applications.

[TIP]
.[RemarquePreTitre]#Question# Ai-je besoin d'une application universelle ?
====
Il y a trois principales raisons _de tendre vers_ la conception  d'applications universelles :

- vous éditez une application web monopage sans alternative accessible ou sans pré-rendu HTML ;
- vous remarquez des doublons de code entre l'application web et son pendant côté serveur ;
- vous pensez qu'une partie de la logique côté serveur pourrait être réutilisée côté web.

Le cas échéant, on peut penser que vous n'avez qu'une faible fraction de votre métier à partager entre les deux environnements.
====

Nous allons aborder la *notion de code universel de manière progressive* et itérative dans les prochaines pages de l'ouvrage.

Nous parlerons d'abord de partage modulaire, de chaîne de construction, de remplacement de code à la volée avant de nous intéresser à un mécanisme de rendu universel basé sur la librairie React.

Il s'agit d'une approche parmi d'autres, "simple" : je vous encourage à regarder ce qui se dit et ce qui se fait ailleurs.

==== Effectuer une requête HTTP

[CAUTION]
.[RemarquePreTitre]#Pré-requis# Démarrage du serveur local
====
Les exemples suivant s'appuient sur un serveur embarqué présent dans le dépôt GitHub des exemples du chapitre 4.

Il sert statiquement le répertoire d'exemples sur le port 4000 de la manière suivante :

.chapter-04/examples
----
$ npm start
----
====

Il est fréquent d'avoir à effectuer des requêtes HTTP pour obtenir des données distantes.
L'implémentation, les contraintes techniques et les mesures de sécurité d'une telle requête sont pourtant foncièrement différentes entre Node et un navigateur Web.
Node fait appel aux modules *http* et *https* tandis que le navigateur dispose nativement de l'objet *XMLHttpRequest*, *XMLHttpRequest level 2* (depuis HTML5) ainsi que de *fetch* (depuis _ES2015_).

Nous n'avons pas encore attaqué l'implémentation technique que la _simple requête_ paraît déjà compliquée en terme d'_universalité_.

Le module _superagent_ émerge en tête des résultats si l'on recherche _browser_ et _http_ dans le registre _npm_.
Le module promet de fonctionner aussi bien avec Node qu'avec différents navigateurs Web, Internet Explorer 8 inclus.
Prometteur non ?


[TIP]
.[RemarquePreTitre]#npm# superagent
====
Le module _superagent_ abstrait l'accès au réseau via une API fluide et chainable.
Sa documentation en ligne détaille la gestion des verbes HTTP, l'envoi des données et la construction des paramètres d'URL.

- [URL]#https://npmjs.com/superagent#
- [URL]#https://visionmedia.github.io/superagent/#
====

Notre exemple se focalise sur l'interrogation d'une URL et l'affichage de sa réponse dans la console :

[source,javascript]
.universal-http/index.js
----
include::{sourceDir}/universal-http/index.js[]
----
<1> La fonction `require()` n'existe pas nativement dans le navigateur donc on ne charge le module _superagent_ que dans Node ;
<2> Affiche `[ 'Chaource', 'Stilton', 'Camembert' ]`.

Ce même fichier `index.js` doit être inclus dans une page HTML afin d'être interprété et exécuté par un navigateur Web :

[source,html]
.universal-http/index.html
----
include::{sourceDir}/universal-http/index.html[]
----
<1> Puisque la fonction `require()` n'est pas disponible nativement dans les navigateurs, on se charge d'injecter `superagent` dans l'espace global ;
<2> Affiche `[ 'Chaource', 'Stilton', 'Camembert' ]` lorsque le navigateur est dirigé vers `http://localhost:4000/src/universal-http/index.html`.

Nous avons créé notre premier code universel, fonctionnant aussi bien dans un navigateur qu'avec Node !
Toutefois, on est tenté d'_hésiter entre magie et bricolage_ … Est-on obligé de recourir à des conditions ECMAScript pour éviter d'exécuter des APIs propres à Node ? Et surtout, *que se passe-t-il sous le capot de _superagent_* pour parvenir à un tel résultat ?

Il est grand temps de parler de _browserify_.

[[browserify]]
==== browserify

Le développement de *browserify* a débuté fin 2010 mais a vraiment pris un envol début 2013 avec sa version 2. +
L'object de _browserify_ est de permettre l'utilisation de l'API CommonJS (`require()` etc.) et de réécrire des parties spécifiques de code pour générer du code ECMAScript fonctionnel dans un environnement de navigateur web.

_browserify_ ne cherche pas à être intelligent sur les éléments à remplacer mais offre une interface de transformation (les _transforms_) pour permettre à tout un chacun de réécrire selon ses besoins. +
Ces transformations s'appliquent à deux niveaux :

- les *fichiers*, en les interchangeant lors des appels à la fonction `require()` ;
- l'*arbre syntaxique*, en délégant aux _transforms_ la réécriture des déclarations et des éléments de syntaxe dont ils sont responsables.

Voici quelques exemples de _transforms_ utiles et fréquemment rencontrés dans différents modules :

- _brfs_ : injecte le contenu de fichiers chargés via l'API `fs` ;
- _browserify-hmr_ : remplace les modules à volée dans le navigateur lors d'un changement de code source ;
- _envify_ : remplacement les appels à `process.env` par leur valeur respective au moment de la transformation ;
- _babelify_ : délègue la transpilation de code ECMAScript et JSX à <<babel,Babel>> ;
- _sassify_ : transpile les inclusions de fichiers Sass en code CSS, optionnellement injecté dans le navigateur au chargement du module en question ;
- _es3ify_ : remplace certains éléments de langage en code ECMAScript 3, afin de supporter d'anciens navigateurs comme Internet Explorer 8.

L'exemple suivant illustre une réécriture agnostique de l'environnement d'exécution :

[source,javascript]
.universal-http/index-browserify.js
----
include::{sourceDir}/universal-http/index-browserify.js[]
----

_browserify_ inclut le code nécessaire à l'exécution de l'arbre de dépendances dessiné par les multiples appels à `require()` lors de l'opération de transformation. +
La conversion de code peut s'effectuer depuis l'API Node de browserify mais aussi depuis un terminal :

----
$ npm run browserify
# tâche présente dans `package.json` équivalente à
$ browserify \
 --entrypoint src/universal-http/index-browserify \
 --output src/universal-http/bundle.js
----

Le fichier HTML varie à peine par rapport à notre première tentative.

À noter que nous n'incluons désormais que le fichier généré par _browserify_ :

[source,html]
.universal-http/index-browserify.html
----
include::{sourceDir}/universal-http/index-browserify.html[]
----

On commence à se rendre compte qu'il y a plusieurs notions d'universalité :

- du code ECMAScript interprétable à la fois par Node et par un navigateur web ;
- du code ECMAScript interprétable par Node et converti pour fonctionner dans un navigateur web.

C'est sans compter sur du code interprétable par un navigateur web mais outillé par Node.
Mais nous quittons là les terres de l'universalité.

==== Templates HTML universels avec React

TBD.

==== Stratégies de gestion des ressources frontend

- build externe
- inlining
- extraction

[[automation]]
=== Automatisation et assemblage

TBD.

==== Quel outil choisir ?

npm/grunt/gulp/brunch/webpack : c'est la jungle j'y comprends rien.

==== Scripts npm

- scripts "natifs"
- scripts custom
- composition
- pre/post

==== Gulp

- par tâche
- par target
- tâches personnalisées
- arguments

=== Tester la compatibilité navigateur

TBD.

==== Karma

TBD.

==== BrowserStack

TBD.

==== Internet Explorer

TBD.

=== Conclusion

TBD.