:nodeVersion: v0.10
:nodeNextVersion: v0.12
:es: ECMAScript 5
:esNext: ECMAScript 6
:sourceDir: ../../examples/nodebook.chapter-03/src
:revisionYear: 2014

== [ChapitreNumero]#3# Premier projet

Maintenant que nous en savons davantage sur Node en théorie et en pratique, il est temps de plonger dans quelque chose de plus ambitieux : la gestion d'un projet entier.

Ce chapitre se focalise sur les différentes étapes d'un projet Node, de son initialisation jusqu'à son exécution sur votre poste de travail en passant par l'installation et la vérification de dépendances npm.

====
.Sommaire
- Organiser son espace de travail
- Gérer les différentes étapes du cycle de vie d'un projet Node
- Connaître et choisir des dépendances npm
- Design pattern
====

Comment organiser, installer maintenir du code dans le cadre d'un projet Node ?
C'est la question à laquelle nous allons répondre dans les prochaines pages.

Vos projets peuvent bénéficier de la richesse de l'écosystème npm dont les modules fournissent fonctionnalités, outillage et des utilitaires d'organisation de code dont il serait dommage de se passer.
En plus de vous faire gagner un temps précieux, ils vous éviteront de réinventer la roue.

Nous terminerons le chapitre par un ensemble de _design patterns_ utiles et récurrents.
Les connaître vous facilitera la lecture du code source de modules tiers, tout en vous donnant les moyens de développer des applications optimisant au maximum l'usage des ressources systèmes.

Ces millisecondes et méga-octets de mémoire peuvent avoir l'air de rien du tout … mais ces techniques vous aideront à créer et maintenir des applications résistant à la charge, de quelques dizaines à plusieurs milliers d'utilisateurs en simultané !

=== Cycles de vie d'un projet

La pierre angulaire d'un projet Node est le fichier  `package.json`.
Incontournable, il décrit les composants essentiels du projet.
Il se situe à la racine de chaque module et contient plusieurs catégories d'informations :

- *textuels* : titre, descriptions, liens et licence ;
- *version* : une chaîne respectant le fonctionnement de _node-semver_ ([URL]#https://github.com/isaacs/node-semver#) ;
- *dépendances* : emplacement du module principal et liste explicite de modules nécessaires au bon fonctionnement du projet ;
- *actions* : commandes à exécuter lors des différentes étapes du cycle de vie du projet ;
- *divers* : données de configuration ou utilisées par des modules Node.

.Exemple minimaliste d'un fichier `package.json`
image::{indir}/images/package-json.png[align="center",scaledwidth="85%"]

Le fichier `package.json` est un mécanisme de description, d'installation et de documentation distribué avec les sources de tout projet.

Considérez ce fichier comme obligatoire.
Il explicite les dépendances, facilite leur installation et leurs mises à jour.

Donc tant qu'à faire, autant le créer dès le début d'un projet — même si on ne sait pas encore ce dont on va avoir besoin de manière exhaustive.

==== Initialisation

L'initialisation d'un projet Node passe par la création du fichier `package.json` et ce, quelle que soit sa taille : petit ou grand, application ou module, public ou privé.

Nous pourrions créer ce fichier à la main et le compléter en suivant la spécification.
Cependant il existe une commande bien utile qui réduit le risque d'erreurs et en accélère sa complétion : `npm init`.

===== npm init

L'utilisation de la commande `npm init` est une bonne habitude à prendre pour débuter tout projet Node.

La commande démarre une série de questions interactives.
Certaines réponses seront pré-remplies, par exemple si un dépôt Git ou un fichier README sont détectés.

À l'issue de la série de questions, le fichier `package.json` sera créé dans le répertoire courant.
Ensuite libre à vous de le compléter avec d'autres éléments optionnels de configuration.

.Exemple de questions posées lors de la séquence `npm init`
image::{indir}/images/npm-init.png[align="center",scaledwidth="85%"]

[TIP]
.[RemarquePreTitre]#Commande# npm help json
====
Le détail de chaque clé de configuration est expliqué _via_ cette commande.
Des exemples vous permettront également de mieux comprendre leur utilité.
====

===== Configurer package.json

Que votre projet soit public ou non, il est important de renseigner les champs décrits ci-après.
Ils indiqueront aux utilisateurs les intentions du projet ainsi que l'emplacement des ressources pour en savoir davantage à son propos ou tout simplement, pour y contribuer.

- *name* : il s'agit de l'identifiant du module lorsqu'il est chargé via la fonction `require()`. Ce sera également l'identifiant npm si vous publiez ce module dans un registre public ou privé. Par exemple, si la propriété *name* vaut _nodebook_, le module se chargera via `require('nodebook')` et s'installera avec la commande `npm install nodebook` ;
- *description* : une indication textuelle des objectifs et fonctionnalités du module, écrite généralement en anglais ;
- *version* : chaîne respectant la sémantique _semver_ — par exemple `1.0.0`. Nous verrons un peu plus loin dans ce chapitre comment utiliser intelligemment cette valeur pour assurer des mises à jour tout en préservant la compatibilité descendante au sein des projets dépendant de ce module ;
- *main* : emplacement du fichier Node chargé par défaut lors d'un appel à `require(<name>)`. S'il n'est pas spécifié, Node tentera de charger par défaut le fichier `index.js` ;
- *repository* : objet spécifiant le type de dépôt de code ainsi que son URL. Présent essentiellement à titre informatif ;
- *preferGlobal* : booléen indiquant si ce module a davantage vocation à être installé globalement au niveau du système ou non (`false` par défaut) ;
- *bin* : emplacement du fichier. npm effectue un lien symbolique pour rendre `<name>` disponible en tant qu'exécutable système lors d'une installation globale ;
- *private* : boolean spécifiant que le module ne doit pas être publié dans un registre npm (`false` par défaut) ;
- *dependencies* : objet représentant respectivement en clé/valeur les noms/versions des modules dont le projet dépend ;
- *engines* : objet spécifiant des contraintes de compatibilité suivant la sémantique _semver_ dans lesquelles le projet s'exécute sans accroc. Par exemple `{ "node": "~0.10.0 || ~0.12.0" }` indiquera une compatibilité avec toutes les versions de Node `v0.10` et de Node `v0.12` — une installation sur Node `v0.8` échouera car la compatibilité n'est pas assurée.

[TIP]
.[RemarquePreTitre]#Aide# dependencies, devDependencies, optionalDependencies, peerDependencies
====
Il existe plusieurs types de dépendances, chacune ayant sa propre utilité :

- *dependencies* : dépendances utiles à un fonctionnement en production ;
- *devDependencies* : dépendances utiles uniquement dans le cadre du développement, par exemple pour exécuter des tests ou s'assurer de la qualité du code ou encore empaqueter le projet ;
- *optionalDependencies* : dépendances dont l'installation ne sera pas nécessairement satisfaite, notamment pour des raisons de compatibilité. En général votre code prévoira que le chargement de ces modules via `require()` pourra échouer en prévoyant le traitement des exceptions avec un `try {} catch ()` ;
- *peerDependencies* : modules installés au niveau parent du projet actuel. Pratique couramment employée dans le cas de _plugins_.
====

Voyons maintenant comment organiser notre code au sein de notre espace de travail.

===== Organiser l'espace de travail

Chaque développeur possède sa propre manière de ranger et d'organiser son code.

La méthode suivante combine à la fois du bon sens et les conventions employées par une majorité de modules publiés sur npm. +
Elle a également l’avantage de fonctionner de manière agnostique selon que votre code soit destiné à être exécuté par un navigateur Web ou un système informatique.

Quoiqu’il en soit, l’objectif est de créer des repères pérennes pour naviguer au sein de vos projets de manière similaire — en tous cas, de manière claire et non-anarchique.

----
├── bin
├── config
├── data
├── dist
├── doc
├── lib
│   └── models
├── node_modules
├── src
│   ├── assets
│   │   ├── images
│   │   ├── js
│   │   └── less
│   ├── routes
│   └── views
├── tests
│   ├── fixtures
│   ├── functional
│   └── unit
├── package.json
└── README
----

[TIP]
.[RemarquePreTitre]#Remarque# Persistence des données
====
L’application ne devrait *jamais persister de fichiers* au sein de cette arborescence.

Considérez un emplacement qui persistera aux installations diverses et répétées. +
Cet emplacement sera défini par un fichier de configuration ou une variable d’environnement.
====

La suggestion d’organisation ci-avant s’explique de la manière suivante :

- *bin* : fichiers exécutables depuis un shell ;
- *config* : environnements de configuration pour éviter d’écrire ces valeurs en dur dans le code source ;
- *data* : données diverses (type binaires ou CSV) nécessaires au fonctionnement de l’application ;
- *dist* : artéfacts produits après une compilation ou un résultat de _build_ — souvent une librairie Node prête à l’usage pour le navigateur ou une arborescence d’application prête à être déployée ;
- *doc* : fichiers de documentation relatifs à la version courante de l’application ;
- *lib* : librairie et modèles utilisées par l’application. Ce code peut typiquement grossir suffisamment pour ainsi justifier qu’il soit extrait en tant que projet(s) indépendant(s) ;
- *node_modules* : modules tiers installés automatiquement via la commande npm. Autrement dit, ne créez jamais de fichiers dans ce répertoire autrement que par la commande npm ;
- *src* : code source spécifique au projet, des routes aux vues/templates en passant par les images et le code à compiler (Sass, LESS, JSX etc.) ;
- *tests* : tests unitaires, fonctionnels et _fixtures_ nécessaires à leur fonctionnement ;
- *package.json* : fichier de configuration précédemment décrit dans cet ouvrage ;
- *README* : présentation, description et documentation minimaliste — mais suffisamment pour installer, faire fonctionner et contribuer au projet.

[TIP]
.[RemarquePreTitre]#Remarque# Échafaudage de projet
=====

Certains modules tels que _Yeoman_ ou _Express Generator_  mettent à disposition une commande pour échafauder automatiquement un projet.

Servez-vous en pour automatiser l’initialisation de vos projets — surtout s’il s’agit d’une opération récurrente.

- https://npmjs.org/yo
- https://npmjs.org/express-generator
=====

Intéressons-nous plus particulièrement au répertoire _node_modules_.

===== Ajouter des dépendances

Comme nous l'avons vu auparavant, le répertoire _node_modules_ contient les dépendances requises par la fonction `require()` (lire la section _modules_ du _Chapitre 2_).

Le mécanisme principal d'installation est la commande `npm install`. +
L'installation d'un module est par défaut _locale_ au projet.
Mais elle peut également être globale au système — nous le verrons plus tard.

Il est toutefois recommandé d'installer les modules localement, afin de limiter leur portée uniquement au projet tout en maintenant une dépendance explicite et gérable via le fichier _package.json_.

Déroulons ensemble l'algorithme d'installation de `npm install` par le biais de cet exemple :

----
npm install --save async yargs
----

La commande précédente effectue plusieurs opérations :

1. requête du registre _npmjs.org_ à propos des deux modules _async_ et _yargs_ ;
2. si les modules existent, la version compatible la plus récente est retournée (équivalent à `npm view async version` et `npm view async version` — respectivement `0.9.0` et `1.3.1`) ;
3. téléchargement et décompression des paquets dans les répertoire `node_modules/async` et `node_modules/yargs` ;
4. introspection récursive des dépendances de ces modules et si besoin est, téléchargement et décompression dans leur répertoire _node_modules_ respectif (ici `node_modules/async/node_modules` et `node_modules/yargs/node_modules`) ;
5. inscription de _async_ et de _yargs_ dans la configuration _dependencies_ de notre fichier `package.json`.

.Exemple de résultat de la commande `npm install`
image::{indir}/images/npm-install-save.png[align="center",scaledwidth="85%"]

La commande npm prend soin de télécharger et de persister les dépendances, à la fois dans le répertoire _node_modules_ et dans le fichier _package.json_.
Ce dernier contient désormais une section _dependencies_ :

[source,javascript]
.package.json
----
{
  ...
  "dependencies": {
    "async": "~1.3.1",
    "yargs": "~0.9.0"
  }
}
----

Vous remarquerez que les numéros de versions sont préfixés du symbole `~` (ou `^` selon la version de npm).
Nous y reviendrons 

[TIP]
.[RemarquePreTitre]#Aide# --save, --save-dev, --save-optional et --save-exact
=====
Plusieurs options à la commande npm inscrivent les dépendances dans le fichier _package.json_.
Leur comportement varie légèrement :

- *--save* : enregistre le module dans la clé _dependencies_ ; 
- *--save-exact* : idem que `--save` mais ne rajoute pas de préfixe au numéro de version (exemple : `1.3.1` au lieu de `~1.3.1`) ;
- *--save-dev* : enregistre le module dans la clé _devDependencies_ ;
- *--save-optional* : enregistre le module dans la clé _optionalDependencies_.

Sans la présence de ces options, les modules seront installés dans le répertoire _node_modules_ mais ils n'apparaitront pas dans _package.json_. +
Cela posera problème si vous cherchez à installer ou déployer l'application sur une autre machine ou après avoir effacé le contenu du répertoire _node_modules_.

*Remarque* : il n’existe pas de mécanisme pour enregistrer automatiquement une dépendance en tant que _peerDependency_.
=====

Les modules installés sont désormais manipulables via la fonction `require` au sein de notre code :

[source,javascript]
----
var async = require('async');
vars argv = require('yargs').argv;
----

Maintenant que nous savons installer et sauvegarder des dépendances par le biais du fichier `package.json`, sauvegardons l'état actuel du projet avec un gestionnaire de versions.

===== Versionner son code

Node s'intègre parfaitement avec les gestionnaires de version de code.
Nous illustrerons la démarche à l'aide de Git mais sachez qu'il est tout à fait possible d'utiliser Mercurial, SVN, Team Foundation Server ou tout autre gestionnaire de version gérant les fichiers texte.

La règle est simple : vous pouvez *tout versionner sauf* deux exceptions.
Deux règles suffisent dans la majorité des cas :

- *node_modules* : le fichier _package.json_ contenant déjà les références aux dépendances requises, nous n'avons pas besoin d'en versionner leur code source ;
- **.log* : la commande npm ou l'interpréteur interactif de Node peuvent générer occasionnellement des fichiers log en cas d'erreur.


[source]
.gitignore
----
# Code source des dépendances externes
node_modules

# Erreurs et logs d'exécution de Node/npm
*.log
----

[TIP]
.[RemarquePreTitre]#Astuce# Automatisation sans effort
====
Certains IDE comme WebStorm ou des plateformes comme GitHub vous proposent de créer le fichier _.gitignore_ configuré pour Node.

Une attention sympathique qui vous évitera de versionner inutilement certains fichiers.
====

Versionner le contenu produit dans les deux précédentes sections se résume à ces quelques commandes :

----
git init
git add package.json .gitignore
git commit -m "Premier commit"
git remote add origin git@votre-serveur-git:repo.git
git push origin master
----

La suite du cycle de vie Git sera similaire à ce que vous aviez l'habitude de pratiquer.

À ce stade, nous savons initialiser un projet Node, installer des dépendances et maintenir son état dans un gestionnaire de version.

===== Approche modulaire

La force de Node réside dans sa facilité à créer et réutiliser du code dont la portée est contenue.
C'est un atout considérable pour créer et maintenir du code modulaire ne se limitant pas qu'à une seule application.

Il faut imaginer et penser une application comme étant le sens donné en créant du _liant_ entre des modules encapsulés.

Un exécutable shell configure des modules et retourne une sortie vers le terminal ou des fichiers. +
Une application Web configure des modèles, les expose via des routes et met la sortie en forme au travers d'un formatage JSON ou HTML par exemple.

Une application accepte des informations en entrée : paramètres HTTP, arguments shell etc. +
Une application retourne des informations en sortie : HTML, JSON, binaire etc.

Un module accepte des informations en entrée : valeurs, objets et fonctions ECMAScript. +
Un module retourne des informations en sortie : valeurs, objets et fonctions ECMAScript.

Cela revient à constamment _designer_ des API et à les exposer, que ce soit au travers d'une interface Node, système ou HTTP.

Une application en ligne de commande devrait contenir une orchestration d'API mettant en relation l'intention exprimée par un shell système envers une librairie Node :

[source,javascript]
.snippets/cli-app.js
----
include::{sourceDir}/snippets/cli-app.js[]
----

Une application HTTP devrait contenir une orchestration d'API mettant en relation l'intention exprimée par une requête HTTP envers une application Node :


[source,javascript]
.snippets/http-app.js
----
include::{sourceDir}/snippets/http-app.js[]
----

Une route obéissant elle-aussi au même principe :

[source,javascript]
.snippets/route.js
----
include::{sourceDir}/snippets/route.js[]
----

Nous verrons dans un chapitre ultérieur comment utiliser cette même logique de développement et l'exécuter du côté du navigateur.

Non seulement la modularité renforcera la facilité à tester votre code, à expliciter ses intentions mais en plus il accentuera l'ubiquité de son utilisation.

==== Installation

À ce stade, nous avons toutes les cartes en main pour créer une application Node.

Il ne reste plus qu'à pouvoir l'installer, dans un état identique sur un autre poste de travail, dans un environnement de test ou de production ou encore en tant que dépendance d'un autre module/projet ou à l'échelle du système.

Dans tous les cas décrits ci-après, que ce soit via Git ou via une archive, npm requiert que le fichier `package.json` soit situé à sa racine.

===== Autonome

Une installation autonome concerne aussi bien un développeur ayant besoin de contribuer à un projet qu'un projet exposant une ou plusieurs interfaces.

La procédure d'installation est relativement simple :

1. Cloner le dépôt Git ;
1. Lancer la commande `npm install`.

Dans le cadre des exemples contenus dans ce chapitre, il suffirait d'exécuter ces commandes :

----
git clone https://github.com/oncletom/nodebook.chapter-03.git
cd nodebook.chapter-03
npm install
----

Vous remarquerez que la commande `npm install` est utilisée seule, sans npm de module.
Dans ce cas, npm se contente d'installer récursivement les dépendances listées dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#npm# --production
====
Si vous suffixez la commande `npm install` avec l'option `--production`, toutes les dépendances seront installées à _l'exception_ de celles listées en tant que _devDependences_.

Il s'agit d'un moyen d'installer moins de dépendance lors d'une livraison — à condition de ne pas avoir besoin de l'outillage de tests.
====

Le clonage du dépôt pour être remplacé par des méthodes alternatives, de type empaquetage sous forme de fichier DEB, de module Puppet, d'archive ZIP … ou encore d'archive Node via la commande `npm pack`.

Ces méthodes permettent entre autre d'inclure les dépendances contenues dans le répertoire _node_modules_ et de garantir la version exacte de l'intégralité de l'arbre de dépendance. 

===== Locale

Dans le cas où votre projet n'est pas autonome et/ou expose une API Node _mais_ n'est pas disponible dans un registre npm, il existe tout de même une méthode d'installation à partir d'un dépôt Git :

----
npm install --save git+https://github.com/oncletom/nodebook.chapter-03.git#master
----

Si l'interface HTTP de Git n'est pas disponible ou que son authentification est exclusivement gérée à partir de certificat SSH, vous pouvez opter pour le préfixe `git+ssh` :

----
npm install --save git+ssh://git@github.com:oncletom/nodebook.chapter-03.git#master
----

À défaut d'un dépôt Git, vous pouvez également installer une dépendance à partir d'une archive Tar compressée (extension `.tar.gz`), produite à l'aide de `npm pack` par exemple.

----
npm install --save https://github.com/oncletom/nodebook.chapter-03/archive/master.tar.gz
----

===== Globale

L'installation globale est une installation rendant disponible votre module sur tout le système d'exploitation.

Il s'agit d'une installation à privilégier pour les modules Node exposant un ou plusieurs exécutables — ces exécutables ayant une vocation utilitaire pour l'utilisateur final ou pour interagir avec d'autres programmes informatiques.

----
npm install -g npm
----

L'exécution de la précédente commande installera la dernière version de npm et rendra disponible l'exécutable du même nom au niveau du système.

Bravo, vous venez d'apprendre à mettre à jour l'exécutable npm !

[TIP]
.[RemarquePreTitre]#npm# Répertoires et exécutables
====
npm se charge de créer les liens symboliques pour vous.
Et ce, en fonction du contexte d'installation — qu'il soit global ou local donc.

- `npm install -g jshint` : exécutable mis à disposition dans le répertoire `\`npm config get npm config get prefix\`/bin` (par exemple `/usr/local/node/bin`) ;
- `npm install jshint` : exécutable mis à disposition dans le répertoire `./node_modules/.bin`.
====

==== Configuration

Certaines applications ou modules nécessitent d'en savoir plus sur le contexte d'exécution, l'emplacement de ressources ou la manière de se connecter à des serveurs distants, par exemple.

C'est à la fois une bonne pratique en terme de flexibilité … et en même temps, vous n'aurez surement pas envie de partager publiquement vos identifiants de base de données, qu'elles contiennent ou pas des informations sensibles.

===== Variables d'environnement

L'utilisation d'une variable d'environnement pour configurer l'exécution d'une application est la solution la plus aisée à implémenter.

Ces variables sont accessibles via l'objet `process.env` et ce, quel que soit le contexte d'exécution de Node.

L'exemple suivant décrit comment définir le port sur lequel écoutera le serveur HTTP en fonction d'un contexte d'exécution (environnement de test ou environnement de production) ou d'un réglage surchargeant le dit contexte.

[source,javascript]
.snippets/config-env.js
----
include::{sourceDir}/snippets/config-env.js[]
----

Ainsi que l'illustration de leur définition (ou non) :

----
PORT=8000 node src/snippets/config-env.js <1>
NODE_ENV=test node src/snippets/config-env.js <2>
node src/snippets/config-env.js <3>
----
<1> Le port sélectionné est le port 8000 ;
<2> Le port sélectionné est le port 3001 ;
<3> Le port sélectionné (par défaut) est le port 3000.

Ces variables d'environnement ont l'avantage d'avoir une portée au niveau du processus uniquement ou d'être propagées à l'échelle du système — via `export` en bash, par exemple.

===== Arguments

Les arguments correspondent à un tableau de chaînes exposé par `process.argv`.

Cette approche est recommandée si la passation d'informations fait partie de la logique métier du module Node, requiert des arguments obligatoires ou implique un _parsing_ avancé.

Le script suivant illustre leur lecture par l'interpréteur Node :

[source,javascript]
.snippets/config-argv.js
----
include::{sourceDir}/snippets/config-argv.js[]
----

Et leur invocation :

----
node src/snippets/config-argv.js -y 2014 2012 --title 'fromage baguette'
----
<1> Affiche `["-y", "2014", "2012", "--title", "fromage baguette"]`.

C'est rudimentaire mais heureusement des parseurs d'arguments vont nous faciliter la vie.
Ils permettent de configurer des valeurs par défaut, de valider les valeurs, de les rendre obligatoire et même de générer automatiquement une aide à l'utilisateur.

L'un de ces modules est `yargs`.
Nous l'avons évoqué et installé précédemment dans ce chapitre.

[source,javascript]
.snippets/config-yargs.js
----
include::{sourceDir}/snippets/config-yargs.js[]
----

Et leur invocation :

----
node src/snippets/config-yargs.js 2012 --title 'fromage baguette' <1> <2> <3>
----
<1> 2014 (sa valeur étant définie par défaut si `-y` n'est pas spécifié comme argument shell) ;
<2> fromage baguette ;
<3> 2012 (`_` étant l'attribut fourre-tout récupérant les arguments non-assignés).

L'invocation suivante omet volontairement l'argument `--title` afin de tester le comportement du module :

----
node src/snippets/config-yargs.js <1>
----
<1> Affiche le message suivant en flux d'erreur (`process.stderr`) : `Missing required arguments: title`.

Consultez la documentation de ce module pour davantage d'exemples variés et avancés.

===== Fichier de configuration

Opter pour un fichier de configuration fait sens si de nombreux paramètres sont à fournir à l'application — ou si certains de ces paramètres impliquent des arborescences d'objets ou de tableaux ECMAScript.

Plusieurs stratégies s'offrent à vous :

- un fichier unique pour éviter les valeurs en dur dans le code ;
- un fichier par environnement d'exécution (test, préprod, production etc.) ;
- un fichier par domaine d'application (base de données, API etc.) ;
- un fichier par domaine de sécurité (backend, frontend etc.).

Le choix reste ouvert et le votre.
En revanche nous allons voir comment _techniquement_ mettre en œuvre ces possibles stratégies.

Commençons par l'approche par environnement d'exécution, reposant sur la notion d'un fichier de configuration par environnement.

[source,javascript]
.snippets/config-file.js
----
include::{sourceDir}/snippets/config-file.js[]
----

Ainsi, un appel au module précédent chargera :

- `production.json` lors du premier appel ;
- `dev.json` lors du second appel ;
- `test.json` lors du premier appel si `NODE_ENV=test` ;
- `dev.json` lors du second appel si `NODE_ENV=test`.

[TIP]
.[RemarquePreTitre]#npm# Le module nconf
====
Des modules comme _nconf_ proposent des abstractions gérant de multiples cas de figure.

Ils vont jusqu'à la prise en charge des notions d'héritage et de cascade pour faciliter la maintenance et ne gérer que les différences entre environnement, plutôt que d'avoir à tout spécifier à chaque fois.

- https://npmjs.org/nconf
====

Une autre approche, tout aussi voire plus simple consiste à réutiliser le fichier `package.json` en y ajoutant des propriétés supplémentaires.

[source,javascript]
.snippets/config-file-package.js
----
include::{sourceDir}/snippets/config-file-package.js[]
----
<1> Affiche `{ port: '3000' }`.

On peut également se passer de l'étape `require()` si la commande npm invoque un script Node :

[source,javascript]
.snippets/config-file-npm.js
----
include::{sourceDir}/snippets/config-file-npm.js[]
----

npm aplatira la structure d'objet du fichier `package.json` et séparera chaque niveau de profondeur par le caractère `_`, le préfixera par `npm_package_` et l'injectera dans l'objet `process.env`. +
Par exemple, `require('./package.json').config.port` sera accessible via `process.env.npm_package_config_port`.

----
node src/snippets/config-file-npm.js <1>
npm run display-config-port <2>
----
<1> Affiche `undefined` ;
<2> Affiche `3000`.

On comprend ainsi que l'exposition du contenu du fichier `package.json` sous forme de variables d'environnement est l'œuvre de la commande npm.

[TIP]
.[RemarquePreTitre]#Astuce# Combinaison avec les variables d'environnement
====
Un bon moyen de ne pas inscrire en dur l'emplacement d'un fichier de configuration est encore d'indiquer son emplacement via une variable d'environnement :

----
CONFIG_FILE=~/.secured/config.json node app.js
----
====

==== Exécution de l'application

Nous avons vu les différentes manières d'utiliser l'interpréteur Node dans le _chapitre 2_.
Pour autant, comment exécuter une application — un programme dont la durée d'exécution est indéfini et de longue durée ?

Il existe plusieurs méthodes, allant de la simple exécution d'un  script Node à l'utilisation de gestionnaire de processus voire même des gestionnaires système tels que _System V_ ou _systemd_.

===== Invocation Node

L'utilisation seule de l'interpréteur Node pour démarrer une application est évidemment la plus simple mais également la moins robuste.

----
node server.js
----

Elle est pratique et acceptable dans le cadre d'un développement local voire encore dans le cadre d'un exécutable à usage ponctuel.

[TIP]
.[RemarquePreTitre]#module# nodemon
====
_nodemon_ est un excellent moyen d'automatiser le rechargement de votre application quand vous la développez.
Dès qu'un fichier est modifié, le module interrompt le serveur et le relance aussitôt avec les arguments originels.

Installez le module globalement et ensuite, au lieu d'exécuter `node server.js`, exécutez `nodemon server.js`.
C'est tout !

- https://npmjs.org/nodemon
====

Une technique "de pauvre" consisterait à utiliser le symbole _&_ afin de rendre la main au système — sans pour autant transformer le processus en _daemon_. +
L'inconvénient de cette méthode est que le processus sera interrompu par le système si vous quittez votre session shell — ce qui sera le cas lors d'une connexion distante via SSH :

----
node server.js &
----

Enfin, dernière alternative : l'utilisation de la commande `nohup` pour demander au système de ne pas interrompre le processus en cas de fin de session.

----
nohup server.js &
----

Quoiqu'il advienne, les solutions précédemment citées n'adresseront pas les problématiques suivantes :

- démarrage automatique du processus ;
- notification et reprise sur erreur en cas de plantage de l'application ;
- redémarrage ou arrêt des services.

===== Invocation npm

L'invocation npm diffère peu de l'invocation Node précédemment décrite : elle souffre en effet des mêmes défauts de résilience.

Alors pourquoi parler de npm ?
N'est-ce pas un outil simplement dédié à la gestion des modules externes ?

La commande npm propose des fonctionnalités additionnelles complétant et facilitant la gestion du processus applicatif. +
Une de ces fonctionnalités est `npm start` :

----
npm start
----

Cette commande ne fait rien en soit si ce n'est exécuter la commande contenue dans la section `scripts.start` de votre fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "start": "node server.js"
  }
}
----

L'avantage de cette approche est double :

- uniformisation du _workflow_ au sein de tous les projets ;
- npm modifie la variable système `$PATH` et rend disponible les exécutables contenus dans le répertoire `./node_modules/.bin` (voir l'encadré _Répertoires et exécutables_ de la section _Installation_).

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "jshint ./src" <1>
  },
  "devDependencies": {
    "jshint": "~2.5.1"
  }
}
----
<1> Équivaut donc à `./node_modules/.bin/jshint ./src`.

Depuis sa version `2.0`, npm expose également les commandes `npm stop` et `npm restart`.

===== Orchestration des services

Nous venons de voir différentes manières d'instancier des applications … mais aucune d'entre elle n'est vraiment satisfaisante en terme de résistance.
À la moindre erreur, tout tombe !

C'est sans compter sur le fait que vos modules contiendront plusieurs serveurs ou _daemons_ à initialiser … voire encore, vous aurez plusieurs serveurs ou _daemons_ répartis dans plusieurs projets différents.

_forever_ est un module populaire dédié à la gestion et au monitoring de process, et pas spécifiquement Node d'ailleurs. +

La commande suivante aura pour effet de démarrer et de placer le processus `server.js` — un _daemon_.

----
forever start server.js
----

Il y a deux gains évidents à cet outillage :

- le processus persistera à la fermeture de la session ;
- la gestion centralisée des processus.

_forever_ créera autant de processus que vous le désirez tout en fournissant un interface pour redémarrer les services, les arrêter, consulter leur logs ou encore afficher à l'écran l'ensemble processus actifs :

----
$ forever list
info:    Forever processes running
data:        uid  command                  script  pid   logfile           uptime
data:    [0] _sHw /usr/bin/node www.js     15594   15610 /var/log/_sHw.log 0:0:1:59.865
data:    [1] vytX /usr/bin/node api.js     15655   15671 /var/log/vytX.log 0:0:1:38.980
data:    [2] MOrx /usr/bin/node bin/cli.js 15769   15785 /var/log/MOrx.log 0:0:0:57.960
----

Cerise sur le gâteau : une application qui plante sera relancée automatiquement par _forever_.
À vous ensuite d'inspecter les logs d'erreurs et de mettre en place un mécanisme d'alerte pour ne pas faire perdurer ces exceptions.

Toutefois, revers de la médaille : il vous faudra exécuter _forever_ autant de fois qu'une application a de processus à démarrer.

[TIP]
.[RemarquePreTitre]#Outil# forever
====
Une documentation détaillée accompagnée d'exemples est disponible sur le dépôt GitHub du projet :

- [URL]#https://github.com/nodejitsu/forever#
====

_Foreman_ est un programme écrit en Ruby.
Il est destiné à gérer les multiples processus d'une même application. +
C'est l'outil que vous devrez utiliser pour démarrer vos applications sur par la plateforme Heroku après déploiement.

Vos différents processus sont à déclarer dans un fichier `Procfile`, somme toute assez simpliste :

[source]
.Procfile
----
web: node www.js
api: PORT=$PORT node api.js
worker: node bin/cli.js --retries 3
----

Le précédent exemple fait état de trois processus à démarrer, dont certains avec des arguments spécifiques.

La commande suivante démarrera ces trois services, créera deux processus pour le module `api.js` en leur attribuant automatiquement un port différent grâce à :

----
foreman start -c api=2
----

[TIP]
.[RemarquePreTitre]#Outil# foreman
====
D'autres fonctionnalités et paramètres de configuration sont expliqués dans la documentation officielle du projet :

- [URL]#http://ddollar.github.io/foreman/#
====

Il ne nous manque qu'une seule chose désormais : pouvoir démarrer nos processus avec le système d'exploitation, après un démarrage ou redémarrage.
Un bénéfice non-négligeable de l'intégration avec le système d'exploitation est la combinaison avec les outils de monitoring et d'agrégation de logs.

_Upstart_ est l'outil de gestion de processus de la distribution Linux Ubuntu.
Sa configuration est une des plus faciles à apprendre :

[source]
./etc/init/your-app
----
start on startup

exec /usr/bin/node /path/to/your/app.js
----

Cette configuration ultra simpliste décrit la commande à exécuter, et quand lancer automatiquement le service.
Dans ce cas, au démarrage du système.

[TIP]
.[RemarquePreTitre]#Outil# Upstart
====
Une introduction ainsi qu'une documentation détaillée d'_Upstart_ est disponible à l'adresse suivante :

- [URL]#http://upstart.ubuntu.com/cookbook/#
====

L'apprentissage et le débogage de tels scripts peut se révéler fastidieuse et rébarbative … _foreman_ dispose d'une fonctionnalité d'export adressant le problème.
Pensez-y !

Nous avons progressivement outillé l'exécution et la prise en charge de nos applications.
Maintenant intéressons-nous aux impacts de la modification d'une application en service.

==== Modification de l'application

Vous disposez d'une application qui démarre et dont le versionning est mis en place … mais concrètement, on fait quoi quand le code change ?

Cette section s'intéresse aux habitudes à prendre avant de pousser le code modifié dans votre dépôt.

===== Mise à jour des dépendances

L'erreur classique : l'application fonctionne sur votre machine mais pas sur celle de votre collègue.
Un module manque mais vous ne comprenez pas pourquoi …

Ça se résume en deux points :

- vous avez une dépendance installée dans votre projet qui n'est pas déclarée dans le fichier `package.json` ;
- la version de vos dépendances et celle de l'autre personne diffèrent.

La commande npm adresse très exactement ces problèmes grâce aux actions suivantes :

----
npm prune
npm update
----

La première supprimera du répertoire _node_modules_ toute dépendance non-déclarée dans le fichier `package.json`.
La seconde installera les dépendances manquantes et mettra à jour les dépendances locales.

`npm update` se comporte de manière similaire à `npm install` à une différence près : les dépendances préalablement installées seront mises à jour si nécessaire.

Ces deux commandes vous assureront un état d'installation similaire à ce qu'une personne aurait en procédant à une installation _fraîche_.

[TIP]
.[RemarquePreTitre]#npm# EPEERINVALID
====
Il se peut qu'une erreur _EPEERINVALID_ se déclare lors d'une mise à jour ou d'une fraîche installation.

image::{indir}/images/npm-outdated-peerinvalid.png[align="center",scaledwidth="85%"]

Cela signifie qu'un paquet réclame une dépendance d'une version différente et incompatible avec celle que vous déclarer dans votre fichier `package.json`.

Trois solutions s'offrent à vous :

- monter en version sur le module incriminé (dans notre exemple, le module `browserify`) ;
- si la version la plus récente de ce module casse la compatibilité de votre application, sélectionnez une version majeure satisfaisant la condition de compatibilité (ici, `>= 3.20.5`) ;
- en dernier recours, supprimer le contenu de _node_modules_ et tout réinstaller proprement — des fois cela suffit à écarter les conflits de version.
====

===== Exécution des tests

L'écriture de tests et la vérification de la qualité de votre code sont un excellent moyen de vous assurez que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un château de carte : le moindre changement accentue le risque de propager des erreurs dans tous les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un contexte d'exécution dédié aux tests :

----
npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec d'autres actions basées sur un état de réussite des tests :

----
npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run code-quality && npm run unit-tests",
    "code-quality": "jshint src/",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "jshint": "*"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json` tout en bénéficiant d'une indépendance d'exécution de vos commandes.

===== Choisir un bon numéro de version

Bien versionner chaque publication de votre projet n'apporte que des avantages.
Et ce, que vous choisissiez ou non de publier vos modules dans un registre npm public ou privé.

Modifier le numéro de version dans votre fichier `package.json` revient à déclarer deux choses :

1. l'*intention du changement*, à savoir mineur, fonctionnel ou très important ;
2. un `git tag` s'impose, pour marquer l'historique de version et faciliter la *reprise du code à un stade identique* à celui livré en production ou dans le registre npm.

Il est temps d'expliquer la spécification _semver_ pour mieux comprendre en tirer profit.

Un numéro de version suivant la logique _semver_ est structuré en quatre parties : MAJEUR.MINEUR.PATCH-EXTRA.

- *Majeur* : changement important d'API cassant la compatibilité avec les versions majeures précédentes ;
- *Mineur* : changement fonctionnel d'API ne cassant pas la compatibilité avec les autres publications associées à la même version majeure ;
- *Patch* : changement trivial impliquant souvent un simple correctif et n'ayant aucun impact de compatibilité ;
- *Extra* (optionnel) : métadonnée spécifique indiquant le statut (beta, alpha etc.), la cible (architecture de CPU, compilateur visé etc.) ou autre (identifiant de commit, numéro de _build_ ayant généré le paquet etc.).

Autrement dit, si vous modifier le numéro de version de `1.1.1` vers :

- `2.0.0` : incompatibilité de code avec toutes les versions de la branche `1.x` ;
- `1.2.0` : fonctionnalités modifiées mais compatibles avec le reste de la branche `1.x` ;
- `1.1.2` : correctif de la version `1.1.1` ;
- `1.1.2-beta.2` : deuxième version beta du correctif de la version `1.1.1`.

À ce stade, nous sommes dans le déclaratif : chaque projet ajoutant une dépendance vers un autre module _choisit_ sa manière d'accepter les nouvelles versions.

===== Publication du code

Puisque nous utilisons un outil de suivi de version comme Git, il est facile non seulement d'installer le projet sur les machines autorisées.
Mais il est aussi aisé d'utiliser ce même mécanisme pour déclarer notre code comme dépendance d'un autre de nos projets.

Dans le cas où votre module est publié dans un dépôt Git privé, accessible au travers de SSH, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+ssh://git@votre-serveur-git:projet/module.git#branche"
  }
}
----

Seules les personnes ayant un accès SSH à ce dépôt seront à même d'obtenir le code au travers de la commande `npm install`.

Dans le cas où votre module est publié dans un dépôt Git public accessible au travers de HTTP, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+https://votre-serveur-git/projet/module.git#branche"
  }
}
----

[TIP]
.[RemarquePreTitre]#npm# Mise à jour d'une dépendance Git
====
La commande `npm update` actualise vos dépendances … sauf les dépendances Git.

Pour mettre à jour une dépendance Git, il vous faut recourir à la commande … `npm install`.
====

Enfin, optez pour une publication dans le registre npm si vous considérez votre projet comme étant suffisamment solide et testé pour être partagé avec les communautés Node.

Cette simple commande suffit à déclarer une nouvelle version :

----
npm publish
----

`npm publish` téléversera une archive compressée associée au numéro de version déclaré par le fichier `package.json` et contenant tous les fichiers du projet.
Tous les fichiers sauf ceux correspondant aux motifs déclarés dans les fichiers `.gitignore` et `.npmignore`.

Pour résumer, si le module est nommé `nodebook` et est en version `1.3.0`, `npm publish` enregistrera cette version dans le registre npm.
L'installation du module fraichement publié est accessible à travers ces différentes variantes :

----
npm install nodebook
npm install nodebook@latest
npm install nodebook@1.3.0
----

Utilisez l'installation versionnée pour installer spécifiquement cette version à tout moment :

----
npm install --save-exact nodebook@1.3.0
----

==== Opérations de routine

Votre projet fonctionne de manière autonome.
Mieux encore : il n'y a plus de bug à corriger ni de nouvelle fonctionnalité à apporter pour le moment.

Alors que faire d'une application Node en production avant qu'elle ne prenne la poussière ?

===== Vérifier l'état des dépendances

Maintenir ses dépendances à jour est important pour deux raisons :

- colmater des bugs qui pourraient se répercuter sur votre application ;
- se prémunir de faille de sécurité mettant en danger vos données et votre système informatique.

En dernier recours, vérifier la fraîcheur de ses dépendances permet de prendre connaissance de nouvelles versions majeures ou mineures dont vous pourriez bénéficier.

Quoiqu'il en soit, une commande npm nous aidera une fois de plus à obtenir les informations voulues :

----
npm outdated
----

La lecture de sa sortie peut être déroutante au premier abord, notamment dans le cas d'un module qui n'a pas été mis à jour via `npm update` depuis un moment :

.Résultats obsolètes issue de `npm outdated`
image::{indir}/images/npm-outdated.png[align="center",scaledwidth="85%"]

Le tableau ne liste que les dépendances considérées comme obsolètes en l'état actuel d'installation de votre projet.
Il se peut donc que le résultat varie d'une machine à l'autre, en fonction des versions installées localement. +
Les résultats est divisé en cinq colonnes :

- *Package* : npm du paquet concerné — en jaune une dépendance qui sera satisfaite en cas de `npm update`, en rouge une dépendance qui nécessite une mise à jour manuelle ;
- *Current* : version installée localement — _MISSING_ sera affiché si la dépendance n'est pas encore installée, _git_ indique que la dépendance est installée via git ;
- *Wanted* : version installée après exécution de `npm update` ;
- *Latest* : version la plus récente publiée dans le registre npm ;
- *Location* : emplacement de la dépendance — dépendance directe ou dépendance incluse dans une autre dépendance etc.

[TIP]
.[RemarquePreTitre]#Remarque# Et si une dépendance n'est pas listée ?
====
Toute dépendance listée dans le fichier `package.json` mais absente du tableau est considérée comme à jour.
====

La première action à mener est de procéder à l'exécution de la commande `npm update`, puis de relancer la commande `npm outdated` :

.Résultats `npm outdated` après mise à jour
image::{indir}/images/npm-outdated-wanted.png[align="center",scaledwidth="85%"]

Le résultat est probant : de nombreuses dépendances précédemment listées en rouge on disparu.
Il ne reste que trois dépendances sur lesquelles nous pouvons avoir une action directe en modifiant la version référencées dans le fichier `package.json`.

Pour forcer l'installation de la version correspondant à la colonne _Latest_ de la commande `npm outdated`, il suffit d'utiliser le suffixe `@latest` lors de l'installation :

----
npm install --save-dev grunt-contrib-uglify@latest
----

Et ainsi de suite pour les autres dépendances de premier niveau.
Voici ce qui est affiché après l'installation de nouvelles versions majeures :

.Résultats obsolètes issue de `npm outdated`
image::{indir}/images/npm-outdated-uptodate.png.png[align="center",scaledwidth="85%"]

On ne peut faire mieux en l'état car :

- une dépendance Git apparaîtra systématiquement car npm n'a aucun moyen de connaître s'il s'agit de la dernière version en date ;
- les dépendances de second niveau (et plus) ne sont pas maitrisables si le paquet reposant sur celles-ci est à jour.

[TIP]
.[RemarquePreTitre]#Outil# David
====
L'outil en ligne _David_ se charge de vérifier l'état des dépendances de chaque module publié dans le registre npm.

Le moyen le plus simple étant de souscrire au flux RSS de chacun de vos modules publié dans le registre afin d'être notifié de leur obsolescence.

- [URL]#https://david-dm.org/#
====

===== Éclater sa base de code

Le temps sédimente votre base de code.
Elle grossit, se densifie et devient à chaque fois un peu plus difficile à lire et naviguer.

Plusieurs raisons peuvent vous pousser à extraire une partie de votre code afin de le placer dans un autre module :

- le besoin de partager la logique métier d'une application avec une autre application ;
- une portion de votre application n'est pas spécifique à son métier et gagnerait à devenir autonome ;
- un composant pourrait être partagé et réutilisé dans un contexte  Web ;
- un besoin de clarification des dépendances de votre application ainsi que de leur documentation ;
- les chemins de vos appels à `require()` deviennent longs et compliqués.

C'est quelque chose de facilement identifiable à l'œil nu :

[source,javascript]
----
var User = require('../../lib/model/user.js');
var Validator = require('../app/middlewares/validator');
var csvParser = require('../../lib/parsers/csv');
----

Dans le cas présent, ces trois modules pourrait être extraits dans les modules indépendants suivants :

- *my-app-models* : pour bénéficier d'un module global gérant tous vos modèles de données — la limite se présentera quand vous aurez beaucoup de modèles dont la compatibilité occasionnera des collisions ;
- *my-app-models-user* : pour bénéficier d'un module dédié à la description de la persistence d'un utilisateur ;
- *validator-middleware* : pour bénéficier d'un module de validation générique et disponible dans le registre npm ;
- *csv-parser* : pour bénéficier d'un parseur CSV utilisable dans toutes vos applications — avez-vous pensé à regarder dans le registre npm avant de réinventer la roue ? ;-)

Il s'agit d'une logique de maintenabilité et d'expression des intentions de votre application.
Elle sera plus facile à maintenir si elle rend isole et rend explicite les dépendances entre les différents modules. +
À moins que vous ne soyiez fan du code spaghetti ;-)

===== Alertes de sécurité

Il existe quatre niveaux où des failles de sécurité peuvent s'immiscer :

- votre propre code — des revues de code, une amélioration de vos connaissances et la commande d'audits vous aideront à identifier les possibles failles et vulnérabilités ;
- des vulnérabilités contenues dans vos dépendances, et dépendances de vos dépendances ;
- des vulnérabilités occasionnées par Node ;
- des vulnérabilités occasionnées par V8, dont le développement est indépendant du projet Node.

On n'oubliera pas les vulnérabilités liés à votre système d'exploitation, à ses logiciels ainsi qu'à son exposition au monde extérieur — mais ce n'est pas l'objet de cet ouvrage.

Plusieurs canaux sont à votre disposition pour être notifié très rapidement de mises à jour correctives :

- *Failles de sécurité de modules npm* : [URL]#https://nodesecurity.io/advisories# — et son flux RSS [URL]#https://nodesecurity.io/rss.xml# ;
- *Failles de sécurité de Node* : [URL]#http://blog.nodejs.org/vulnerability/# — et son flux RSS [URL]#http://blog.nodejs.org/feed/vulnerability/# ;
- *Mises à jour de Node* : [URL]#http://blog.nodejs.org/# — et son flux RSS [URL]#http://blog.nodejs.org/feed/#.

=== Bien utiliser npm

Le registre npm fourmille de modules en tous genres.
Ils fournissent de simples fonctions, des librairies ou des _frameworks_ complets pour gérer vos accès réseau, vos bases de données, la qualité de vos projets et leur automatisation.

Mais comment se retrouver dans cette jungle contenant plusieurs dizaines de millier de modules ?

==== Chercher un module

Le site Web du registre npm ([URL]#https://npmjs.org#) est _la_ ressource incontournable.
Le site liste l'intégralité des modules récents, des modules populaires et des auteurs populaires.

Les résultats sont triés en fonction de la correspondance avec l'expression recherchée … ce qui peut se révéler compliqué si vous cherchez avec les mauvais termes ou que vous ne connaissez pas le terme anglo-saxon adapté.

Pour en savoir plus sur la manière de choisir un module, et de séparer le grain de l'ivraie, reportez-vous à la section suivante.

La commande `npm search` est une alternative au site Web.
Son algorithme d'affichage est d'ailleurs identique. +
Astuce : si le motif de recherche est encadré par le caractère `/`, la commande npm effectuera la requête via une expression régulière :

.npm search /slug/
image::{indir}/images/npm-search-cli.png[align="center",scaledwidth="85%"]

Enfin, le projet _npmsearch_ ([URL]#http://npmsearch.com#) est une initiative indépendante dont le but est de proposer une interface optimisée pour la recherche de modules Node.
Ses principaux avantages sont la rapidité d'affichage des résultats, ainsi qu'un tri par défaut orienté sur la *pertinence*.

Cette pertinence est évaluée selon certains des critères évoqués ci-après.

==== Critères de sélection d'un module

La sélection d'un module est un choix subjectif : la qualité, la pertinence et la popularité sont corrélé sans pour autant être des critères impératifs. +
Un module peu populaire sera-t-il moins bon pour autant ? Un module populaire est-il plus performant qu'une alternative ? Un module bien testé sera-t-il plus aisé à utiliser ?

Bref, pour vous aider à choisir — et ce peu importe le contexte — voici une liste subjective de critères et leur impact sur votre processus de décision :

- *documentation* : un fichier _README_ décrivant l'API ou une *documentation technique illustrée d'exemples* sont des exemples d'objectif de qualité aidant tant à l'utilisation qu'à la contribution du-dit module ;
- *badge d'intégration continue* : la présence de tests est indispensable pour assurer une certaine qualité. Le badge d'intégration continue est un mécanisme supplémentaire pour démontrer l'*existence de tests* et leur *automatisation* lors de toute contribution de code ;
- *dépendances* : l'existence de modules reposant sur un autre démontre une *marque de confiance* d'autres développeurs. Confiance suffisante dans la solidité des fondations sur lesquelles ils s'appuient pour bâtir leur propre module ;
- *date de mise à jour* : une ou plusieurs versions majeures de Node sont-elles sorties entre temps ? Si oui, des *risques d'incompatibilité* peuvent se présenter. Certaines dépendances peuvent également être devenues obsolètes ou avoir présenté des failles de sécurité ;
- *maintenance* : si personne ne met à jour le module alors que des contributions se présentent, cela peut se révéler bloquant, dénoter une *obsolescence* d'idée ou impliquer l'existence d'un _fork_ de ce module ;
- *état des contributions* : les mainteneurs répondent-ils aux contributeurs ? Les contributions de code sont-elles acceptées dans des conditions légitimes ? Ou tout simplement, y'a-t-il beaucoup de déclaration de bugs en suspens ? Telles sont les indicateurs de vitalité pour estimer la gravité et la probabilité que la librairie nous explose au visage lorsqu'on ne s'y attendra pas.

.Résultats `npm outdated` après mise à jour
image::{indir}/images/module-npm-ok.png[align="center",scaledwidth="85%"]

.Exemple de module
image::{indir}/images/module-npm-ko.png[align="center",scaledwidth="85%"]

Enfin, n'oubliez pas qu'il s'agit de critères subjectifs.
Les mainteneurs du module ne sont peut-être pas de bons communicants ou n'ont que peu d'expérience en terme de tests … ou ils n'ont tout simplement pas eu le temps. +
N'hésitez pas à les encourager si vos expérimentations se révèlent concluantes.
Contribuez des tests et de la documentation à hauteur de votre temps.
Même s'il ne s'agit _que_ de cinq lignes de code, d'un exemple supplémentaire ou d'une faute d'orthographe en moins.

C'est comme cela que l'écosystème s'améliore petit à petit … et que vous apprenez par la même occasion.

==== Sélection de modules npm

Débuter dans un océan de plusieurs dizaines de millier de modules npm reste une chose peu aisée.

Les prochaines pages de l'ouvrage dressent une liste non-exhaustive de modules fréquemment employés et appréciés par les communautés de développeurs Node.

===== Manipulations diverses

Ces librairies adressent des besoins quotidiens en terme de manipulation de chaîne ou de dates.
Elles vous permettront aussi d'organiser votre code en exécutant des fonctions de manière séquentielles, parallèles ou en boucles asynchrones.

====== lodash

_lodash_ est une excellente librairie de manipulation de tableaux, d'objets, de fonctions et de chaînes.

Vous pourrez ainsi boucler, filtrer, extraire et composer sans vous soucier de la compatibilité de l'environnement d'exécution.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/lodash#

[source,javascript]
.npm-lodash.js
----
include::{sourceDir}/snippets/npm-lodash.js[]
----
<1> Affiche `['A', 'B', 'C', 'D']`.

====== async

_async_ est une librairie de gestion de fonctions asynchrones.
Son but ?
Pouvoir itérer sur des tableaux de manière asynchrone, exécuter des _callbacks_ de manière séquentielle ou gérer une pile d'exécution de _n_ fonctions en parallèle.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/async#

[source,javascript]
.npm-async.js
----
include::{sourceDir}/snippets/npm-async.js[]
----
<1> Affiche `['A', 'B', 'C', 'D']`.

====== string

_string_ est un utilitaire de manipulation de chaînes de caractère.
Le module fournit des méthodes pour échapper, nettoyer, tronquer, remplacer, compter … entre autre.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/string#

[source,javascript]
.npm-string.js
----
include::{sourceDir}/snippets/npm-string.js[]
----
<1> `blog-post` ;
<2> `<h1>Blog Post</h1>` ;
<3> `\&lt;h1\&gt;Blog Post\&lt;/h1\&gt;`.

====== bluebird

_bluebird_ est une libraire de gestion de promesses (voir ci-après la section _Design patterns_).
Elle est performante et propose de nombreuses méthodes pour organiser des flux asynchrones tout en gérant les cas d'erreur sans s'arracher les cheveux.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/bluebird#

[source,javascript]
.npm-bluebird.js
----
include::{sourceDir}/snippets/npm-bluebird.js[]
----
<1> Affiche un tableau de noms de paquet manquants, en l'occurrence `['yargs']`.

====== moment

_moment_ est une librairie de gestion de temps.
Elle simple énormément le _parsing_ des chaînes, l'ajout/soustraction de durées et propose des utilitaires de formatage d'affichage qui vous feront gagner un temps précieux.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/moment#

[source,javascript]
.npm-moment.js
----
include::{sourceDir}/snippets/npm-moment.js[]
----
<1> Affiche `2014-09-10T23:00:00.000Z` ;
<1> Affiche `13/09/14` ;
<1> Affiche `2 jours`.

====== eventemitter2

_eventemitter2_ est une librairie performante de gestion d'événements.
Elle introduit la notion d'espace de nom et de durée de vie d'événement.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/eventemitter2#

[source,javascript]
.npm-eventemitter2.js
----
include::{sourceDir}/snippets/npm-eventemitter2.js[]
----
<1> Affiche `['ping', 'ping']` ;
<2> N'affiche rien, l'événement étant désormais déconnecté.

===== Système de fichier

Ces librairies adressent des besoins quotidiens de manipulation de fichiers, que ce soit leur création, suppression mais aussi leur sélection ou l'écoute d'événements liés à ces activités.

====== mkdirp

_mkdirp_ est identique à la commande UNIX `mkdir -p`.
C'est à dire que les répertoires seront créés récursivement s'ils n'existent pas au préalable.

[URL]#https://npmjs.org/mkdirp#

[source,javascript]
.npm-mkdirp.js
----
include::{sourceDir}/snippets/npm-mkdirp.js[]
----

L'exemple précédent illustre l'écriture de la date courante dans un fichier.
Ce fichier n'est écrit que lorsque l'arborescence est préalablement créée.

====== rimraf

_rimraf_ est le pendant inverse de _mkdirp_ : il supprime une arborescence de manière récursive.

[URL]#https://npmjs.org/rimraf#

[source,javascript]
.npm-rimraf.js
----
include::{sourceDir}/snippets/npm-rimraf.js[]
----

====== glob

_glob_ est un utilitaire très pratique pour filtrer une recherche récursive au sein du système de fichiers.

Sa syntaxe équivalente à ce qui se fait dans le monde UNIX évite  une écriture de code complexe reposant sur l'API `fs`.

[URL]#https://npmjs.org/glob#

[source,javascript]
.npm-glob.js
----
include::{sourceDir}/snippets/npm-glob.js[]
----
<1> Affiche `['bin/cli.js', 'src/snippets/cli-app.js']`.

====== fs-extra

_fs-extra_ complète _rimraf_ et _mkdirp_ et ajoute d'autres fonctions utilitaires telles que la copie et le déplacement récursifs.

[URL]#https://npmjs.org/fs-extra#

[source,javascript]
.npm-fs-extra.js
----
include::{sourceDir}/snippets/npm-fs-extra.js[]
----

====== graceful-fs

_graceful-fs_ n'apporte aucune API supplémentaire à l'API native Node `fs`.
Sous le capot la librairie simplifie l'écriture de notre code en tentant plusieurs fois d'accéder à un fichier si celui-ci n'est pas disponible.
Un module qui vous sera utile si l'activité de lecture et d'écriture sur disque dépasse les capacités du système.

[URL]#https://npmjs.org/graceful-fs#

[source,javascript]
.npm-graceful-fs.js
----
include::{sourceDir}/snippets/npm-graceful-fs.js[]
----
<1> Affiche `nodebook.chapter-03`.

====== chokidar

_chokidar_ normalise l'observation du système de fichiers pour une très grande majorité de systèmes d'exploitation.
La librairie ajoute quelques fonctionnalités de filtre, de persistance d'observation et permet de dynamiquement ajouter ou retirer des fichiers de l'observation.

[URL]#https://npmjs.org/chokidar#

[source,javascript]
.npm-chokidar.js
----
include::{sourceDir}/snippets/npm-chokidar.js[]
----

L'exemple ci-contre surveille un répertoire dans lequel le script `npm-mkdirp.js` écrit.
Sans surprise, la sortie reflète les actions décrites quelques pages auparavant :

----
addDir - tmp
addDir - tmp/blah
addDir - tmp/blah/blah
add - tmp/blah/blah/now.txt
----

===== Base de données

Node supporte un vaste ensemble de bases de données grâce aux modules npm.
Favorisez toujours les modules faisant état de _driver_ natif/binaire : la communication vers la base de données n'en sera que plus rapide.

====== knex

_knex_ est une librairie de manipulation de base de données SQL.
Elle est notamment compatible avec PostgreSQL, MariaDB, MySQL et SQLite.
Son API fluide basée sur des _callbacks_ et des _promesses_ vous sera précieuse pour ne pas écrire de requête à la main.

Les auteurs de _knex_ ont également créé la surcouche _bookshelf_ pour la partie ORM, et donc gérer des modèles de données au lieu de requêtes SQL.

[URL]#https://npmjs.org/knex# et [URL]#https://npmjs.org/bookshelf#

[source,javascript]
.npm-knex.js
----
include::{sourceDir}/snippets/npm-knex.js[]
----

L'exemple précédent se charge de créer une table dans une base de données SQLite, puis y insère trois nouveaux enregistrements.

====== mongoose

_mongoose_ est un _ODM_ pour MongoDB.
Il vous aidera à composer vos modèles, gérer la connexion à la base de données mais aussi à définir des comportements annexes comme des mixins ou des _getters_ dynamiques.

[URL]#https://npmjs.org/mongoose#

[source,javascript]
.npm-mongoose.js
----
include::{sourceDir}/snippets/npm-mongoose.js[]
----

====== levelup

_LevelDB_ est un système de base de données clé/valeur extrêmement modulaire, avec un stockage sur disque par défaut mais pouvant évoluer vers du stockage en mémoire … et dans un contexte de navigateur Web !

[URL]#https://npmjs.org/levelup#

[source,javascript]
.npm-levelup.js
----
include::{sourceDir}/snippets/npm-levelup.js[]
----

====== redis

_redis_ est une autre base de données clé/valeur focalisée sur la performance et la distribution sur de multiples serveurs.

_hiredis_ est un _driver_ C++ pouvant être utilisé par le module Node _redis_.
Il permet de travailler directement avec des buffers plutôt qu'avec des conversions JSON, ce qui accélère le processus de conversion/déconversion depuis la base de données.

[URL]#https://npmjs.org/redis# et 
[URL]#https://npmjs.org/hiredis#

[source,javascript]
.npm-redis.js
----
include::{sourceDir}/snippets/npm-redis.js[]
----

===== Ligne de commande

Nous l'avions déjà entraperçu dans le chapitre 2 mais Node nous révèle un outillage facilitant les interactions dans un environnement _bash_.

====== yargs

_yargs_ est une librairie de _parsing_ et de validation d'arguments.
Elle vous aidera à gérer les valeurs par défaut, à rejeter toute option inconnue ou encore à accumuler les valeurs d'options identiques.

Si seul le _parsing_ vous intéresse, optez pour _minimist_.

[URL]#https://npmjs.org/yargs#

Référez-vous à la section _Approche modulaire_ de ce même chapitre pour un exemple plus détaillé de cette librairie.

====== chalk

_chalk_ est un simple outil de colorisation et de mise en forme de texte dans un terminal.
Oubliez les code ANSI, _chalk_ ne vous demandera que deux appels de fonction pour afficher un texte en bleu, italique et souligné !

[URL]#https://npmjs.org/chalk#

[source,javascript]
.npm-chalk.js
----
include::{sourceDir}/snippets/npm-chalk.js[]
----

Ce script produira l'affichage suivant :

image::{indir}/images/npm-chalk.png[align="center",scaledwidth="85%"]

====== cli-table

_cli-table_ est un utilitaire permettant de transformer un tableau de primitives ou d'objets ECMAScript en un tableau visuel dans le terminal.
Des options vous permettent de gérer la ligne d'entête et la largeur des colonnes, entre autre.

[URL]#https://npmjs.org/cli-table#

[source,javascript]
.npm-cli-table.js
----
include::{sourceDir}/snippets/npm-cli-table.js[]
----

Ce script produira l'affichage suivant :

image::{indir}/images/npm-cli-table.png[align="center",scaledwidth="85%"]

====== inquirer

_inquirer_ est le composant qu'il vous faut pour gérer l'interactivité avec un utilisateur dans le terminal : questions à choix multiple, validation de saisie, texte libre multiple etc.

[URL]#https://npmjs.org/inquirer#

[source,javascript]
.npm-inquirer.js
----
include::{sourceDir}/snippets/npm-inquirer.js[]
----

Le programme précédent tente de charger le module Node saisi par l'utilisateur et rejette la réponse s'il n'existe pas.

La saisie est préalablement nettoyée pour éviter que le chargement d'un module local puisse aboutir.

===== HTTP et API

Une majorité d'articles et de tutoriaux pour Node ont pour habitude d'illustrer la création d'un serveur HTTP.
S'il est vrai que Node rend les interactions réseaux aisées grâce à leur gestion non-bloquante, créer un serveur respectant réellement la spécification du protocole HTTP est une autre paire de manches.

La plupart des modules n'imposant pas de choix d'architecture, vous aurez souvent à composer vous-même votre application HTTP en fonction de vos besoins.

====== express

_express_ est probablement la librairie la plus populaire.
Elle gère le routage HTTP et la passation de données vers le moteur de rendu de votre choix.
Son système de _middlewares_

Peu d'aspects de sécurité sont pris en charge.
Il est fortement recommandé de lui adjoindre _helmet_ ou d'opter pour _kraken_, une surcouche d'_express_ configurée dans cette optique.

[URL]#https://npmjs.org/express#, [URL]#https://npmjs.org/helmet# et [URL]#https://npmjs.org/kraken-js#

Référez-vous à la section _Approche modulaire_ de ce même chapitre pour un exemple plus détaillé de cette librairie.

====== passport

_passport_ est une librairie de gestion d'authentification.
De nombreux modules complémentaires permettent de gérer une authentification par mot de passe, par OAuth, par compte Google Apps etc.

Elle fonctionne particulièrement bien puisqu'elle n'impose pas de mécanisme de persistence d'utilisateurs ni de session.

[URL]#https://npmjs.org/passport#

Référez-vous à sa documentation pour des exemples détaillés d'utilisation et d'implémentation au sein de votre application.

====== restify

_restify_ est une alternative à _express_ si votre application n'a pour seul but que d'exposer une API REST, sans rendu HTML ou nécessitant un templating particulier.

Elle rend possible le débogage complet à partir de _dtrace_, la gestion des versions d'API et expose un client permettant de consommer des données sur d'autres API REST.

[URL]#https://npmjs.org/restify#

[source,javascript]
.npm-restify.js
----
include::{sourceDir}/snippets/npm-restify.js[]
----

L'exemple précédent expose une même route permettant d'obtenir des informations sur les déclarations de versions d'un fichier `package.json`.

Par défaut, la version 2 de l'API est utilisée :

----
$ curl http://localhost:8080/modules/express
{"modules":[{"name":"express","version":"4.9.5"}]}
----

Une version obsolète de l'API peut toutefois être utilisée si l'on mentionne explicitement cette information :

----
$ curl -H 'Accept-version: ~1' http://localhost:8080/modules/express
"^4.9.5"
----

====== socket.io

_socket.io_ est à la fois un serveur et un client Websocket.
Autrement dit, de la gestion de communication en temps réel entre un client et un serveur.

En cas d'incompatibilité du client, la librairie propose des solutions alternatives (Flash, JSONP, AJAX).

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/socket.io#

[source,javascript]
.npm-socket.io.js
----
include::{sourceDir}/snippets/npm-socket.io.js[]
----

===== Préprocesseurs

Les préprocesseurs sont des outils de productivité transformant un langage vers un autre langage, en général compatible avec une majorité de navigateurs.

Certains vous permettront même de compiler du code Node vers du code compatible avec un navigateur Web.

====== less

_less_ est un préprocesseur permettant de compiler vers du code CSS.
Ses atouts résident dans la gestion des variables, de _mixins_ et de fonctions encourageant une écriture modulaire, plus logique et plus succincte.

Sass est son alternative la plus populaire, en Ruby.
Un portage partiel en C++ est accessible en Node via le module _node-sass_ — beaucoup plus performant et recommandé si vous n'avez pas besoin des fonctionnalités les plus avancées de Sass.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/less# et [URL]#https://npmjs.org/node-sass#

[source]
.npm-less.less
----
include::{sourceDir}/snippets/npm-less.less[]
----

====== rework

_rework_ est une alternative à Less et Sass dans le sens où vous définissez les règles de votre préprocesseur … y compris si cela revient à écrire vos propres règles.

[URL]#https://npmjs.org/rework#

[source,javascript]
.npm-rework.js
----
include::{sourceDir}/snippets/npm-rework.js[]
----

====== browserify

_browserify_ transforme des modules CommonJS et des appels aux API Node en un code ECMAScript capable d'être exécuté dans un navigateur Web.

Un puissant mécanisme de _transforms_ introduit des remplacements de modules à la volée ou le mélange de modules AMD et CommonJS.

Une alternative à _browserify_ est _webpack_.
Aux fonctionnalités précédemment listées s'ajoutent une prise en charge plus aisée de multiples modules ainsi que la compilation de fichiers CSS ou Less.

[URL]#https://npmjs.org/browserify# et [URL]#https://npmjs.org/webpack#

[source,javascript]
.npm-browserify.js
----
include::{sourceDir}/snippets/npm-browserify.js[]
----
<1> Affiche `Open Sky`.

[source,javascript]
.package.json
----
{
  "browser": {
    "cheerio": "jquery"
  },
  "dependencies": {
    "cheerio": "^0.17.0",
    "jquery": "^2.1.1",
  },
  "devDependencies": {
    "browserify": "^5.0.0"
  }
}
----

La commande `browserify` remplacera l'appel au module _cheerio_ par un appel au module _jquery_ :

----
browserify npm-browserify.js -o npm-browserify.bundle.js
----

Inclus dans un navigateur Web, le fichier `npm-browserify.bundle.js` affichera le même résultat que l'interpréteur Node.

====== traceur

_traceur_ transforme tout code ECMAScript 6 en code compatible ECMAScript 5.
Il peut être utilisé en complément de _browserify_ et de _webkpack_.

[URL]#https://npmjs.org/traceur#

[source,javascript]
.npm-traceur.js
----
include::{sourceDir}/snippets/npm-traceur.js[]
----

----
node npm-traceur-bootstrap.js <1> <2>
----
<1> Affiche `passport@^0.2.1` ;
<2> Affiche `passport-local@^1.0.0`.

====== uglify-js

_uglify-js_ compile de l'ECMAScript en ECMAScript mais en plus de concaténer plusieurs fichiers en un seul, il peut également minifier voire supprimer le code inutilisé par votre application.

[URL]#https://npmjs.org/uglify-js#

[source]
----

----

===== Templating

Les librairies de templating proposent chacune à leur manière d'associer une structure de données à une logique de présentation.

Node n'y échappe pas bien sûr, mais a l'avantage de disposer de langages de templating fonctionnant aussi bien dans un environnement Node que dans des navigateurs Web.

====== swig

_swig_ est un portage de _Twig_, bien connu par les développeurs PHP proche de l'écosystème Symfony.
Sa syntaxe inclut des fonctionnalités comme les filtres, les blocs ou l'héritage de gabarit.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/swig#

[source,javascript]
.template.swig
----
include::{sourceDir}/snippets/template.swig[]
----

====== handlebars

_handlebars_ et son prédécesseur _mustache_ sont les vétérans du templating Node.
Leur parti pris est de proposer le minimum de logique afin que celle-ci reste au plus près des données.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/swig#

[source,javascript]
.template.hbs
----
include::{sourceDir}/snippets/template.hbs[]
----

====== jade

_jade_ s'inspire de _yaml_ en optant pour un parti pris à base d'indentation et d'un balisage dépourvu de chevron.
Son mécanisme de blocs facilite la réutilisation de logiques d'affichage au sein de votre application.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/jade#

[source,javascript]
.template.jade
----
include::{sourceDir}/snippets/template.jade[]
----

====== ejs

_ejs_ part du principe qu'il n'y a pas besoin d'un langage de templating autre qu'ECMAScript.
Donc c'est tout simplement ce qui vous sera proposé, impliquant de ce fait une faible courbe d'apprentissage.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/ejs#

[source,javascript]
.template.ejs
----
include::{sourceDir}/snippets/template.ejs[]
----

====== react

_react_ est une librairie de présentation essentiellement connue pour son approche efficace du côté des navigateurs Web.
Ce qui est moins connu en revanche est sa capacité à pouvoir également générer du balisage côté Node, et de servir de moteur de rendu pour des _frameworks_ comme _express_.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/react#

[source,javascript]
.template.jsx
----
include::{sourceDir}/snippets/template.jsx[]
----

===== Tests

L'outillage permettant de tester vos applications est également richement fourni.
Il y a bien sûr de quoi couvrir les tests unitaires, générer des couverture de code, exécuter les tests dans différents navigateurs, tester vos API HTTP ou encore créer des _stubs_ et des _mocks_.

[TIP]
.[RemarquePreTitre]#Remarque# require('assert')
====
Node dispose de sa propre API d'assertion : vous pouvez donc vous lancer dans vos premiers tests simplement en exécutant un module Node faisant appel à ce module natif.

Une exception sera levée à chaque fois qu'une assertion ne sera pas satisfaite.

- [URL]#http://nodejs.org/api/assert.html#
====

====== tape

_tape_ est probablement la librairie d'exécution de tests et d'assertion la plus simple qui soit.
Extrêmement simpliste, elle se base sur la sortie de `console.log` pour s'assurer de l'état global d'exécution des tests.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/tape#

[source,javascript]
.npm-tape.js
----
include::{sourceDir}/snippets/npm-tape.js[]
----

====== mocha

_mocha_ est une librairie d'exécution de tests offrant des interfaces TDD, BDD et QUnit — cette dernière facilitant la transition depuis la librairie du même nom.
Sa simplicité et flexibilité d'utilisation en font un choix pertinent pour la majorité de vos projets.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/mocha#

[source,javascript]
.npm-mocha.js
----
include::{sourceDir}/snippets/npm-mocha.js[]
----

====== chai

_chai_ est une librairie d'assertion exposant des interfaces BDD et TDD.
Elle est particulièrement bien fournie pour tester des structures d'objets complètes ou partielles.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/x#

[source,javascript]
.npm-chai.js
----
include::{sourceDir}/snippets/npm-chai.js[]
----

====== sinon

_sinon_ est votre compagnon idéal pour gérer _spys_, _stubs_ et _mocks_.
En d'autres termes, vous prenez la main sur des portions de votre propre API pour vérifier que leur _comportement_ répond comme prévu aux signaux de leur environnement.

_sinon_ peut étendre _chai_ via le module _sinon-chai_ ou être utilisé directement avec le _framework_ de tests _buster_.

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/x#

[source,javascript]
.npm-sinon.js
----
include::{sourceDir}/snippets/npm-sinon.js[]
----

====== blanket

_blanket_ génère une couverture de code en inspectant le code exécuté par vos tests unitaires et en vous signalant les portions de votre applications qui ne sont pas prises en compte par vos tests.

[URL]#https://npmjs.org/blanket#

[source]
----
mocha -r blanket -c html-cov test/**/*.js > coverage.html
----

====== karma

_karma_ est un utilitaire d'exécution de tests unitaires dans un contexte de navigateur Web.
Ces navigateurs peuvent tout aussi bien être ceux présents sur votre machine, que des navigateurs résidant dans une VM ou exécutés à distance via des services comme SauceLabs ou BrowserStack.

[URL]#https://npmjs.org/karma#

.Exemple d'exécution continues de tests avec Karma
image::{indir}/images/karma.png[align="center",scaledwidth="85%"]

====== superagent

_superagent_ est une librairie de tests pour API HTTP.
Autrement dit, au lieu de tester directement le code de votre application, vous testez le comportement de votre API au travers des codes HTTP et des structures de données exposées.

[URL]#https://npmjs.org/superagent#

====== jshint

_jshint_ teste la qualité de votre code et signale des pratiques de programmation à risque.
C'est un excellent moyen d'éviter des bugs tout en uniformisant vos pratiques de codage au sein de vos applications.

Son petit-frère _eslint_ a également le même but à la différence près que les règles de vérification sont programmables … et vous pouvez créer les vôtres.

[URL]#https://npmjs.org/jshint# et [URL]#https://npmjs.org/eslint#

Et la commande exécutant la vérification récursive du code contenu dans le répertoire `src/` :

----
jshint src/
----

===== Automatisation

L'automatisation de tâches et leur inclusion dans vos projets sont d'excellents moyens pour rendre explicite votre outillage tout en le rendant reproductible et vérifiable.

====== grunt

_grunt_ est l'outil qui a propulsé Node dans la cours des développeurs _frontend_.
Son écosystème de modules particulièrement fourni en terme de performance, d'assemblage et de fonctionnalités a définitivement aidé de nombreux développeurs à automatiser bon nombre de tâches dans leurs projets.

[URL]#https://npmjs.org/grunt# et grunt-cli

[source,javascript]
.Gruntfile.js
----
include::{sourceDir}/../Gruntfile.js[]
----

====== gulp

_gulp_ est une alternative à _grunt_ avec un focus sur la performance d'exécution.
Son architecture est entièrement basée sur les _Streams_ rend cette librairie particulièrement efficace pour les traitements de fichiers impliquant plusieurs transformations.

[URL]#https://npmjs.org/gulp#

[source,javascript]
.Gulpfile.js
----
include::{sourceDir}/../Gulpfile.js[]
----
 
====== forever

_forever_ est un utilitaire permettant de démarrer des processus en tâche de fond ou en tant que _daemon_.
Une bonne pratique est ensuite de déléguer la gestion des logs au système d'exploitation (par exemple _logrotate_) et de notifier des plantages par email ou un autre canal de communication.

Si le mécanisme ne vous paraît pas adéquat, optez pour des mécanismes système comme _Upstart_, _foreman_ ou _monit_.

[URL]#https://npmjs.org/forever# et [URL]#https://npmjs.org/pm2#

[source]
----
----

====== Yeoman

_yo_ est le nom de la commande exécutable de _Yeoman_.
Cet outil est adapté à l'échafaudage interactif d'applications ou de parties d'application (nouveau gabarit, nouveau composant).

[URL]#https://npmjs.org/yo#

[source]
----

----

==== Internet of Things

====== nitrogen

[URL]#https://npmjs.org/nitrogen#

- device + features
- service
- server relaying

====== serialport

[URL]#https://npmjs.org/serialport#

[source,javascript]
.npm-serialport.js
----
include::{sourceDir}/snippets/npm-serialport.js[]
----

====== firmata

[URL]#https://npmjs.org/firmata#

[source,javascript]
.npm-firmata.js
----
include::{sourceDir}/snippets/npm-firmata.js[]
----

====== johnny-five

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/johnny-five#

[source,javascript]
.npm-johnny-five.js
----
include::{sourceDir}/snippets/npm-johnny-five.js[]
----

====== cylon

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/cylon#

[source,javascript]
.npm-cylon.js
----
include::{sourceDir}/snippets/npm-cylon.js[]
----

====== node-red

Compatible Node et navigateurs Web. +
[URL]#https://npmjs.org/node-red#



==== Auteurs et communautés de confiance

Des organisations et des individus contribuent activement à Node en mettant à disposition une large majorité de leurs créations.

La liste suivante est non-exhaustive et référence des contributeurs de qualité :

- substack ([URL]#https://npmjs.org/~substack#) ;
- jshttp ([URL]#https://github.com/jshttp#) ;
- nodejitsu ([URL]#https://github.com/nodejitsu#) ;
- mafintosh ([URL]#https://npmjs.org/~mafintosh#) ;
- feross ([URL]#https://npmjs.org/~feross#) ;
- dougwilson ([URL]#https://npmjs.org/~dougwilson#) ;
- isaacs ([URL]#https://npmjs.org/~isaacs#) ;
- fgribreau ([URL]#https://npmjs.org/~fgribreau#).

=== Design patterns

==== index.js

==== Globbing

==== Injection de module

==== Callback

==== Event

==== Promesses

==== Streams

==== Bloquant / non-bloquant / synchrone / asynchrone


