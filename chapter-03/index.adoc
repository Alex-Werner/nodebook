:nodeVersion: v0.10
:nodeNextVersion: v0.12
:es: ECMAScript 5
:esNext: ECMAScript 6
:sourceDir: ../../examples/nodebook.chapter-03/src
:revisionYear: 2014

== [ChapitreNumero]#3# Premier projet

Maintenant que nous en savons davantage sur Node en théorie et en pratique, il est temps de plonger dans quelque chose de plus ambitieux : la gestion d'un projet entier.

Ce chapitre se focalise sur les différentes étapes d'un projet Node, de son initialisation jusqu'à son exécution sur votre poste de travail en passant par l'installation et la vérification de dépendances npm.

====
.Sommaire
- Organiser son espace de travail
- Gérer les différentes étapes du cycle de vie d'un projet Node
- Connaître et choisir des dépendances npm
- Design pattern
====

Comment organiser, installer maintenir du code dans le cadre d'un projet Node ?
C'est la question à laquelle nous allons répondre dans les prochaines pages.

Vos projets peuvent bénéficier de la richesse de l'écosystème npm dont les modules fournissent fonctionnalités, outillage et des utilitaires d'organisation de code dont il serait dommage de se passer.
En plus de vous faire gagner un temps précieux, ils vous éviteront de réinventer la roue.

Nous terminerons le chapitre par un ensemble de _design patterns_ utiles et récurrents.
Les connaître vous facilitera la lecture du code source de modules tiers, tout en vous donnant les moyens de développer des applications optimisant au maximum l'usage des ressources systèmes.

Ces millisecondes et méga-octets de mémoire peuvent avoir l'air de rien du tout … mais ces techniques vous aideront à créer et maintenir des applications résistant à la charge, de quelques dizaines à plusieurs milliers d'utilisateurs en simultané !

=== Cycles de vie d'un projet

La pierre angulaire d'un projet Node est le fichier  `package.json`.
Incontournable, il décrit les composants essentiels du projet.
Il se situe à la racine de chaque module et contient plusieurs catégories d'informations :

- *textuels* : titre, descriptions, liens et licence ;
- *version* : une chaîne respectant le fonctionnement de _node-semver_ ([URL]#https://github.com/isaacs/node-semver#) ;
- *dépendances* : emplacement du module principal et liste explicite de modules nécessaires au bon fonctionnement du projet ;
- *actions* : commandes à exécuter lors des différentes étapes du cycle de vie du projet ;
- *divers* : données de configuration ou utilisées par des modules Node.

.Exemple minimaliste d'un fichier `package.json`
image::{indir}/images/package-json.png[align="center",scaledwidth="85%"]

Le fichier `package.json` est un mécanisme de description, d'installation et de documentation distribué avec les sources de tout projet.

Considérez ce fichier comme obligatoire.
Il explicite les dépendances, facilite leur installation et leurs mises à jour.

Donc tant qu'à faire, autant le créer dès le début d'un projet — même si on ne sait pas encore ce dont on va avoir besoin de manière exhaustive.

==== Initialisation

L'initialisation d'un projet Node passe par la création du fichier `package.json` et ce, quelle que soit sa taille : petit ou grand, application ou module, public ou privé.

Nous pourrions créer ce fichier à la main et le compléter en suivant la spécification.
Cependant il existe une commande bien utile qui réduit le risque d'erreurs et en accélère sa complétion : `npm init`.

===== npm init

L'utilisation de la commande `npm init` est une bonne habitude à prendre pour débuter tout projet Node.

La commande démarre une série de questions interactives.
Certaines réponses seront pré-remplies, par exemple si un dépôt Git ou un fichier README sont détectés.

À l'issue de la série de questions, le fichier `package.json` sera créé dans le répertoire courant.
Ensuite libre à vous de le compléter avec d'autres éléments optionnels de configuration.

.Exemple de questions posées lors de la séquence `npm init`
image::{indir}/images/npm-init.png[align="center",scaledwidth="85%"]

[TIP]
.[RemarquePreTitre]#Commande# npm help json
====
Le détail de chaque clé de configuration est expliqué _via_ cette commande.
Des exemples vous permettront également de mieux comprendre leur utilité.
====

===== Configurer package.json

Que votre projet soit public ou non, il est important de renseigner les champs décrits ci-après.
Ils indiqueront aux utilisateurs les intentions du projet ainsi que l'emplacement des ressources pour en savoir davantage à son propos ou tout simplement, pour y contribuer.

- *name* : il s'agit de l'identifiant du module lorsqu'il est chargé via la fonction `require()`. Ce sera également l'identifiant npm si vous publiez ce module dans un registre public ou privé. Par exemple, si la propriété *name* vaut _nodebook_, le module se chargera via `require('nodebook')` et s'installera avec la commande `npm install nodebook` ;
- *description* : une indication textuelle des objectifs et fonctionnalités du module, écrite généralement en anglais ;
- *version* : chaîne respectant la sémantique _semver_ — par exemple `1.0.0`. Nous verrons un peu plus loin dans ce chapitre comment utiliser intelligemment cette valeur pour assurer des mises à jour tout en préservant la compatibilité descendante au sein des projets dépendant de ce module ;
- *main* : emplacement du fichier Node chargé par défaut lors d'un appel à `require(<name>)`. S'il n'est pas spécifié, Node tentera de charger par défaut le fichier `index.js` ;
- *repository* : objet spécifiant le type de dépôt de code ainsi que son URL. Présent essentiellement à titre informatif ;
- *preferGlobal* : booléen indiquant si ce module a davantage vocation à être installé globalement au niveau du système ou non (`false` par défaut) ;
- *bin* : emplacement du fichier. npm effectue un lien symbolique pour rendre `<name>` disponible en tant qu'exécutable système lors d'une installation globale ;
- *private* : boolean spécifiant que le module ne doit pas être publié dans un registre npm (`false` par défaut) ;
- *dependencies* : objet représentant respectivement en clé/valeur les noms/versions des modules dont le projet dépend ;
- *engines* : objet spécifiant des contraintes de compatibilité suivant la sémantique _semver_ dans lesquelles le projet s'exécute sans accroc. Par exemple `{ "node": "~0.10.0 || ~0.12.0" }` indiquera une compatibilité avec toutes les versions de Node `v0.10` et de Node `v0.12` — une installation sur Node `v0.8` échouera car la compatibilité n'est pas assurée.

[TIP]
.[RemarquePreTitre]#Aide# dependencies, devDependencies, optionalDependencies, peerDependencies
====
Il existe plusieurs types de dépendances, chacune ayant sa propre utilité :

- *dependencies* : dépendances utiles à un fonctionnement en production ;
- *devDependencies* : dépendances utiles uniquement dans le cadre du développement, par exemple pour exécuter des tests ou s'assurer de la qualité du code ou encore empaqueter le projet ;
- *optionalDependencies* : dépendances dont l'installation ne sera pas nécessairement satisfaite, notamment pour des raisons de compatibilité. En général votre code prévoira que le chargement de ces modules via `require()` pourra échouer en prévoyant le traitement des exceptions avec un `try {} catch ()` ;
- *peerDependencies* : modules installés au niveau parent du projet actuel. Pratique couramment employée dans le cas de _plugins_.
====

Voyons maintenant comment organiser notre code au sein de notre espace de travail.

===== Organiser l'espace de travail

Chaque développeur possède sa propre manière de ranger et d'organiser son code.

La méthode suivante combine à la fois du bon sens et les conventions employées par une majorité de modules publiés sur npm. +
Elle a également l’avantage de fonctionner de manière agnostique selon que votre code soit destiné à être exécuté par un navigateur Web ou un système informatique.

Quoiqu’il en soit, l’objectif est de créer des repères pérennes pour naviguer au sein de vos projets de manière similaire — en tous cas, de manière claire et non-anarchique.

----
├── bin
├── config
├── data
├── dist
├── doc
├── lib
│   └── models
├── node_modules
├── src
│   ├── assets
│   │   ├── images
│   │   ├── js
│   │   └── less
│   ├── routes
│   └── views
├── tests
│   ├── fixtures
│   ├── functional
│   └── unit
├── package.json
└── README
----

[TIP]
.[RemarquePreTitre]#Remarque# Persistence des données
====
L’application ne devrait *jamais persister de fichiers* au sein de cette arborescence.

Considérez un emplacement qui persistera aux installations diverses et répétées. +
Cet emplacement sera défini par un fichier de configuration ou une variable d’environnement.
====

La suggestion d’organisation ci-avant s’explique de la manière suivante :

- *bin* : fichiers exécutables depuis un shell ;
- *config* : environnements de configuration pour éviter d’écrire ces valeurs en dur dans le code source ;
- *data* : données diverses (type binaires ou CSV) nécessaires au fonctionnement de l’application ;
- *dist* : artéfacts produits après une compilation ou un résultat de _build_ — souvent une librairie Node prête à l’usage pour le navigateur ou une arborescence d’application prête à être déployée ;
- *doc* : fichiers de documentation relatifs à la version courante de l’application ;
- *lib* : librairie et modèles utilisées par l’application. Ce code peut typiquement grossir suffisamment pour ainsi justifier qu’il soit extrait en tant que projet(s) indépendant(s) ;
- *node_modules* : modules tiers installés automatiquement via la commande npm. Autrement dit, ne créez jamais de fichiers dans ce répertoire autrement que par la commande npm ;
- *src* : code source spécifique au projet, des routes aux vues/templates en passant par les images et le code à compiler (Sass, LESS, JSX etc.) ;
- *tests* : tests unitaires, fonctionnels et _fixtures_ nécessaires à leur fonctionnement ;
- *package.json* : fichier de configuration précédemment décrit dans cet ouvrage ;
- *README* : présentation, description et documentation minimaliste — mais suffisamment pour installer, faire fonctionner et contribuer au projet.

[TIP]
.[RemarquePreTitre]#Remarque# Échafaudage de projet
=====

Certains modules tels que _Yeoman_ ou _Express Generator_  mettent à disposition une commande pour échafauder automatiquement un projet.

Servez-vous en pour automatiser l’initialisation de vos projets — surtout s’il s’agit d’une opération récurrente.

- https://npmjs.org/yo
- https://npmjs.org/express-generator
=====

Intéressons-nous plus particulièrement au répertoire _node_modules_.

===== Ajouter des dépendances

Comme nous l'avons vu auparavant, le répertoire _node_modules_ contient les dépendances requises par la fonction `require()` (lire la section _modules_ du _Chapitre 2_).

Le mécanisme principal d'installation est la commande `npm install`. +
L'installation d'un module est par défaut _locale_ au projet.
Mais elle peut également être globale au système — nous le verrons plus tard.

Il est toutefois recommandé d'installer les modules localement, afin de limiter leur portée uniquement au projet tout en maintenant une dépendance explicite et gérable via le fichier _package.json_.

Déroulons ensemble l'algorithme d'installation de `npm install` par le biais de cet exemple :

----
npm install --save async yargs
----

La commande précédente effectue plusieurs opérations :

1. requête du registre _npmjs.org_ à propos des deux modules _async_ et _yargs_ ;
2. si les modules existent, la version compatible la plus récente est retournée (équivalent à `npm view async version` et `npm view async version` — respectivement `0.9.0` et `1.3.1`) ;
3. téléchargement et décompression des paquets dans les répertoire `node_modules/async` et `node_modules/yargs` ;
4. introspection récursive des dépendances de ces modules et si besoin est, téléchargement et décompression dans leur répertoire _node_modules_ respectif (ici `node_modules/async/node_modules` et `node_modules/yargs/node_modules`) ;
5. inscription de _async_ et de _yargs_ dans la configuration _dependencies_ de notre fichier `package.json`.

.Exemple de résultat de la commande `npm install`
image::{indir}/images/npm-install-save.png[align="center",scaledwidth="85%"]

La commande npm prend soin de télécharger et de persister les dépendances, à la fois dans le répertoire _node_modules_ et dans le fichier _package.json_.
Ce dernier contient désormais une section _dependencies_ :

[source,javascript]
.package.json
----
{
  ...
  "dependencies": {
    "async": "~1.3.1",
    "yargs": "~0.9.0"
  }
}
----

Vous remarquerez que les numéros de versions sont préfixés du symbole `~` (ou `^` selon la version de npm).
Nous y reviendrons 

[TIP]
.[RemarquePreTitre]#Aide# --save, --save-dev, --save-optional et --save-exact
=====
Plusieurs options à la commande npm inscrivent les dépendances dans le fichier _package.json_.
Leur comportement varie légèrement :

- *--save* : enregistre le module dans la clé _dependencies_ ; 
- *--save-exact* : idem que `--save` mais ne rajoute pas de préfixe au numéro de version (exemple : `1.3.1` au lieu de `~1.3.1`) ;
- *--save-dev* : enregistre le module dans la clé _devDependencies_ ;
- *--save-optional* : enregistre le module dans la clé _optionalDependencies_.

Sans la présence de ces options, les modules seront installés dans le répertoire _node_modules_ mais ils n'apparaitront pas dans _package.json_. +
Cela posera problème si vous cherchez à installer ou déployer l'application sur une autre machine ou après avoir effacé le contenu du répertoire _node_modules_.

*Remarque* : il n’existe pas de mécanisme pour enregistrer automatiquement une dépendance en tant que _peerDependency_.
=====

Les modules installés sont désormais manipulables via la fonction `require` au sein de notre code :

[source,javascript]
----
var async = require('async');
vars argv = require('yargs').argv;
----

Maintenant que nous savons installer et sauvegarder des dépendances par le biais du fichier `package.json`, sauvegardons l'état actuel du projet avec un gestionnaire de versions.

===== Versionner son code

Node s'intègre parfaitement avec les gestionnaires de version de code.
Nous illustrerons la démarche à l'aide de Git mais sachez qu'il est tout à fait possible d'utiliser Mercurial, SVN, Team Foundation Server ou tout autre gestionnaire de version gérant les fichiers texte.

La règle est simple : vous pouvez *tout versionner sauf* deux exceptions.
Deux règles suffisent dans la majorité des cas :

- *node_modules* : le fichier _package.json_ contenant déjà les références aux dépendances requises, nous n'avons pas besoin d'en versionner leur code source ;
- **.log* : la commande npm ou l'interpréteur interactif de Node peuvent générer occasionnellement des fichiers log en cas d'erreur.


[source]
.gitignore
----
# Code source des dépendances externes
node_modules

# Erreurs et logs d'exécution de Node/npm
*.log
----

[TIP]
.[RemarquePreTitre]#Astuce# Automatisation sans effort
====
Certains IDE comme WebStorm ou des plateformes comme GitHub vous proposent de créer le fichier _.gitignore_ configuré pour Node.

Une attention sympathique qui vous évitera de versionner inutilement certains fichiers.
====

Versionner le contenu produit dans les deux précédentes sections se résume à ces quelques commandes :

----
git init
git add package.json .gitignore
git commit -m "Premier commit"
git remote add origin git@votre-serveur-git:repo.git
git push origin master
----

La suite du cycle de vie Git sera similaire à ce que vous aviez l'habitude de pratiquer.

À ce stade, nous savons initialiser un projet Node, installer des dépendances et maintenir son état dans un gestionnaire de version.

===== Approche modulaire

La force de Node réside dans sa facilité à créer et réutiliser du code dont la portée est contenue.
C'est un atout considérable pour créer et maintenir du code modulaire ne se limitant pas qu'à une seule application.

Il faut imaginer et penser une application comme étant le sens donné en créant du _liant_ entre des modules encapsulés.

Un exécutable shell configure des modules et retourne une sortie vers le terminal ou des fichiers. +
Une application Web configure des modèles, les expose via des routes et met la sortie en forme au travers d'un formatage JSON ou HTML par exemple.

Une application accepte des informations en entrée : paramètres HTTP, arguments shell etc. +
Une application retourne des informations en sortie : HTML, JSON, binaire etc.

Un module accepte des informations en entrée : valeurs, objets et fonctions ECMAScript. +
Un module retourne des informations en sortie : valeurs, objets et fonctions ECMAScript.

Cela revient à constamment _designer_ des API et à les exposer, que ce soit au travers d'une interface Node, système ou HTTP.

Une application en ligne de commande devrait contenir une orchestration d'API mettant en relation l'intention exprimée par un shell système envers une librairie Node :

[source,javascript]
.snippets/cli-app.js
----
include::{sourceDir}/snippets/cli-app.js[]
----

Une application HTTP devrait contenir une orchestration d'API mettant en relation l'intention exprimée par une requête HTTP envers une application Node :


[source,javascript]
.snippets/http-app.js
----
include::{sourceDir}/snippets/http-app.js[]
----

Une route obéissant elle-aussi au même principe :

[source,javascript]
.snippets/route.js
----
include::{sourceDir}/snippets/route.js[]
----

Nous verrons dans un chapitre ultérieur comment utiliser cette même logique de développement et l'exécuter du côté du navigateur.

Non seulement la modularité renforcera la facilité à tester votre code, à expliciter ses intentions mais en plus il accentuera l'ubiquité de son utilisation.

==== Installation

À ce stade, nous avons toutes les cartes en main pour créer une application Node.

Il ne reste plus qu'à pouvoir l'installer, dans un état identique sur un autre poste de travail, dans un environnement de test ou de production ou encore en tant que dépendance d'un autre module/projet ou à l'échelle du système.

Dans tous les cas décrits ci-après, que ce soit via Git ou via une archive, npm requiert que le fichier `package.json` soit situé à sa racine.

===== Autonome

Une installation autonome concerne aussi bien un développeur ayant besoin de contribuer à un projet qu'un projet exposant une ou plusieurs interfaces.

La procédure d'installation est relativement simple :

1. Cloner le dépôt Git ;
1. Lancer la commande `npm install`.

Dans le cadre des exemples contenus dans ce chapitre, il suffirait d'exécuter ces commandes :

----
git clone https://github.com/oncletom/nodebook.chapter-03.git
cd nodebook.chapter-03
npm install
----

Vous remarquerez que la commande `npm install` est utilisée seule, sans npm de module.
Dans ce cas, npm se contente d'installer récursivement les dépendances listées dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#npm# --production
====
Si vous suffixez la commande `npm install` avec l'option `--production`, toutes les dépendances seront installées à _l'exception_ de celles listées en tant que _devDependences_.

Il s'agit d'un moyen d'installer moins de dépendance lors d'une livraison — à condition de ne pas avoir besoin de l'outillage de tests.
====

Le clonage du dépôt pour être remplacé par des méthodes alternatives, de type empaquetage sous forme de fichier DEB, de module Puppet, d'archive ZIP … ou encore d'archive Node via la commande `npm pack`.

Ces méthodes permettent entre autre d'inclure les dépendances contenues dans le répertoire _node_modules_ et de garantir la version exacte de l'intégralité de l'arbre de dépendance. 

===== Locale

Dans le cas où votre projet n'est pas autonome et/ou expose une API Node _mais_ n'est pas disponible dans un registre npm, il existe tout de même une méthode d'installation à partir d'un dépôt Git :

----
npm install --save git+https://github.com/oncletom/nodebook.chapter-03.git#master
----

Si l'interface HTTP de Git n'est pas disponible ou que son authentification est exclusivement gérée à partir de certificat SSH, vous pouvez opter pour le préfixe `git+ssh` :

----
npm install --save git+ssh://git@github.com:oncletom/nodebook.chapter-03.git#master
----

À défaut d'un dépôt Git, vous pouvez également installer une dépendance à partir d'une archive Tar compressée (extension `.tar.gz`), produite à l'aide de `npm pack` par exemple.

----
npm install --save https://github.com/oncletom/nodebook.chapter-03/archive/master.tar.gz
----

===== Globale

L'installation globale est une installation rendant disponible votre module sur tout le système d'exploitation.

Il s'agit d'une installation à privilégier pour les modules Node exposant un ou plusieurs exécutables — ces exécutables ayant une vocation utilitaire pour l'utilisateur final ou pour interagir avec d'autres programmes informatiques.

----
npm install -g npm
----

L'exécution de la précédente commande installera la dernière version de npm et rendra disponible l'exécutable du même nom au niveau du système.

Bravo, vous venez d'apprendre à mettre à jour l'exécutable npm !

[TIP]
.[RemarquePreTitre]#npm# Répertoires et exécutables
====
npm se charge de créer les liens symboliques pour vous.
Et ce, en fonction du contexte d'installation — qu'il soit global ou local donc.

- `npm install -g jshint` : exécutable mis à disposition dans le répertoire `\`npm config get npm config get prefix\`/bin` (par exemple `/usr/local/node/bin`) ;
- `npm install jshint` : exécutable mis à disposition dans le répertoire `./node_modules/.bin`.
====

==== Configuration

Certaines applications ou modules nécessitent d'en savoir plus sur le contexte d'exécution, l'emplacement de ressources ou la manière de se connecter à des serveurs distants, par exemple.

C'est à la fois une bonne pratique en terme de flexibilité … et en même temps, vous n'aurez surement pas envie de partager publiquement vos identifiants de base de données, qu'elles contiennent ou pas des informations sensibles.

===== Variables d'environnement

L'utilisation d'une variable d'environnement pour configurer l'exécution d'une application est la solution la plus aisée à implémenter.

Ces variables sont accessibles via l'objet `process.env` et ce, quel que soit le contexte d'exécution de Node.

L'exemple suivant décrit comment définir le port sur lequel écoutera le serveur HTTP en fonction d'un contexte d'exécution (environnement de test ou environnement de production) ou d'un réglage surchargeant le dit contexte.

[source,javascript]
.snippets/config-env.js
----
include::{sourceDir}/snippets/config-env.js[]
----

Ainsi que l'illustration de leur définition (ou non) :

----
PORT=8000 node src/snippets/config-env.js <1>
NODE_ENV=test node src/snippets/config-env.js <2>
node src/snippets/config-env.js <3>
----
<1> Le port sélectionné est le port 8000 ;
<2> Le port sélectionné est le port 3001 ;
<3> Le port sélectionné (par défaut) est le port 3000.

Ces variables d'environnement ont l'avantage d'avoir une portée au niveau du processus uniquement ou d'être propagées à l'échelle du système — via `export` en bash, par exemple.

===== Arguments

Les arguments correspondent à un tableau de chaînes exposé par `process.argv`.

Cette approche est recommandée si la passation d'informations fait partie de la logique métier du module Node, requiert des arguments obligatoires ou implique un _parsing_ avancé.

Le script suivant illustre leur lecture par l'interpréteur Node :

[source,javascript]
.snippets/config-argv.js
----
include::{sourceDir}/snippets/config-argv.js[]
----

Et leur invocation :

----
node src/snippets/config-argv.js -y 2014 2012 --title 'fromage baguette'
----
<1> Affiche `["-y", "2014", "2012", "--title", "fromage baguette"]`.

C'est rudimentaire mais heureusement des parseurs d'arguments vont nous faciliter la vie.
Ils permettent de configurer des valeurs par défaut, de valider les valeurs, de les rendre obligatoire et même de générer automatiquement une aide à l'utilisateur.

L'un de ces modules est `yargs`.
Nous l'avons évoqué et installé précédemment dans ce chapitre.

[source,javascript]
.snippets/config-yargs.js
----
include::{sourceDir}/snippets/config-yargs.js[]
----

Et leur invocation :

----
node src/snippets/config-yargs.js 2012 --title 'fromage baguette' <1> <2> <3>
----
<1> 2014 (sa valeur étant définie par défaut si `-y` n'est pas spécifié comme argument shell) ;
<2> fromage baguette ;
<3> 2012 (`_` étant l'attribut fourre-tout récupérant les arguments non-assignés).

L'invocation suivante omet volontairement l'argument `--title` afin de tester le comportement du module :

----
node src/snippets/config-yargs.js <1>
----
<1> Affiche le message suivant en flux d'erreur (`process.stderr`) : `Missing required arguments: title`.

Consultez la documentation de ce module pour davantage d'exemples variés et avancés.

===== Fichier de configuration

Opter pour un fichier de configuration fait sens si de nombreux paramètres sont à fournir à l'application — ou si certains de ces paramètres impliquent des arborescences d'objets ou de tableaux ECMAScript.

Plusieurs stratégies s'offrent à vous :

- un fichier unique pour éviter les valeurs en dur dans le code ;
- un fichier par environnement d'exécution (test, préprod, production etc.) ;
- un fichier par domaine d'application (base de données, API etc.) ;
- un fichier par domaine de sécurité (backend, frontend etc.).

Le choix reste ouvert et le votre.
En revanche nous allons voir comment _techniquement_ mettre en œuvre ces possibles stratégies.

Commençons par l'approche par environnement d'exécution, reposant sur la notion d'un fichier de configuration par environnement.

[source,javascript]
.snippets/config-file.js
----
include::{sourceDir}/snippets/config-file.js[]
----

Ainsi, un appel au module précédent chargera :

- `production.json` lors du premier appel ;
- `dev.json` lors du second appel ;
- `test.json` lors du premier appel si `NODE_ENV=test` ;
- `dev.json` lors du second appel si `NODE_ENV=test`.

[TIP]
.[RemarquePreTitre]#npm# Le module nconf
====
Des modules comme _nconf_ proposent des abstractions gérant de multiples cas de figure.

Ils vont jusqu'à la prise en charge des notions d'héritage et de cascade pour faciliter la maintenance et ne gérer que les différences entre environnement, plutôt que d'avoir à tout spécifier à chaque fois.

- https://npmjs.org/nconf
====

Une autre approche, tout aussi voire plus simple consiste à réutiliser le fichier `package.json` en y ajoutant des propriétés supplémentaires.

[source,javascript]
.snippets/config-file-package.js
----
include::{sourceDir}/snippets/config-file-package.js[]
----
<1> Affiche `{ port: '3000' }`.

On peut également se passer de l'étape `require()` si la commande npm invoque un script Node :

[source,javascript]
.snippets/config-file-npm.js
----
include::{sourceDir}/snippets/config-file-npm.js[]
----

npm aplatira la structure d'objet du fichier `package.json` et séparera chaque niveau de profondeur par le caractère `_`, le préfixera par `npm_package_` et l'injectera dans l'objet `process.env`. +
Par exemple, `require('./package.json').config.port` sera accessible via `process.env.npm_package_config_port`.

----
node src/snippets/config-file-npm.js <1>
npm run display-config-port <2>
----
<1> Affiche `undefined` ;
<2> Affiche `3000`.

On comprend ainsi que l'exposition du contenu du fichier `package.json` sous forme de variables d'environnement est l'œuvre de la commande npm.

[TIP]
.[RemarquePreTitre]#Astuce# Combinaison avec les variables d'environnement
====
Un bon moyen de ne pas inscrire en dur l'emplacement d'un fichier de configuration est encore d'indiquer son emplacement via une variable d'environnement :

----
CONFIG_FILE=~/.secured/config.json node app.js
----
====

==== Exécution de l'application

Nous avons vu les différentes manières d'utiliser l'interpréteur Node dans le _chapitre 2_.
Pour autant, comment exécuter une application — un programme dont la durée d'exécution est indéfini et de longue durée ?

Il existe plusieurs méthodes, allant de la simple exécution d'un  script Node à l'utilisation de gestionnaire de processus voire même des gestionnaires système tels que _System V_ ou _systemd_.

===== Invocation Node

L'utilisation seule de l'interpréteur Node pour démarrer une application est évidemment la plus simple mais également la moins robuste.

----
node server.js
----

Elle est pratique et acceptable dans le cadre d'un développement local voire encore dans le cadre d'un exécutable à usage ponctuel.

[TIP]
.[RemarquePreTitre]#module# nodemon
====
_nodemon_ est un excellent moyen d'automatiser le rechargement de votre application quand vous la développez.
Dès qu'un fichier est modifié, le module interrompt le serveur et le relance aussitôt avec les arguments originels.

Installez le module globalement et ensuite, au lieu d'exécuter `node server.js`, exécutez `nodemon server.js`.
C'est tout !

- https://npmjs.org/nodemon
====

Une technique "de pauvre" consisterait à utiliser le symbole _&_ afin de rendre la main au système — sans pour autant transformer le processus en _daemon_. +
L'inconvénient de cette méthode est que le processus sera interrompu par le système si vous quittez votre session shell — ce qui sera le cas lors d'une connexion distante via SSH :

----
node server.js &
----

Enfin, dernière alternative : l'utilisation de la commande `nohup` pour demander au système de ne pas interrompre le processus en cas de fin de session.

----
nohup server.js &
----

Quoiqu'il advienne, les solutions précédemment citées n'adresseront pas les problématiques suivantes :

- démarrage automatique du processus ;
- notification et reprise sur erreur en cas de plantage de l'application ;
- redémarrage ou arrêt des services.

===== Invocation npm

L'invocation npm diffère peu de l'invocation Node précédemment décrite : elle souffre en effet des mêmes défauts de résilience.

Alors pourquoi parler de npm ?
N'est-ce pas un outil simplement dédié à la gestion des modules externes ?

La commande npm propose des fonctionnalités additionnelles complétant et facilitant la gestion du processus applicatif. +
Une de ces fonctionnalités est `npm start` :

----
npm start
----

Cette commande ne fait rien en soit si ce n'est exécuter la commande contenue dans la section `scripts.start` de votre fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "start": "node server.js"
  }
}
----

L'avantage de cette approche est double :

- uniformisation du _workflow_ au sein de tous les projets ;
- npm modifie la variable système `$PATH` et rend disponible les exécutables contenus dans le répertoire `./node_modules/.bin` (voir l'encadré _Répertoires et exécutables_ de la section _Installation_).

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "jshint ./src" <1>
  },
  "devDependencies": {
    "jshint": "~2.5.1"
  }
}
----
<1> Équivaut donc à `./node_modules/.bin/jshint ./src`.

Depuis sa version `2.0`, npm expose également les commandes `npm stop` et `npm restart`.

===== Orchestration des services

Nous venons de voir différentes manières d'instancier des applications … mais aucune d'entre elle n'est vraiment satisfaisante en terme de résistance.
À la moindre erreur, tout tombe !

C'est sans compter sur le fait que vos modules contiendront plusieurs serveurs ou _daemons_ à initialiser … voire encore, vous aurez plusieurs serveurs ou _daemons_ répartis dans plusieurs projets différents.

_forever_ est un module populaire dédié à la gestion et au monitoring de process, et pas spécifiquement Node d'ailleurs. +

La commande suivante aura pour effet de démarrer et de placer le processus `server.js` — un _daemon_.

----
forever start server.js
----

Il y a deux gains évidents à cet outillage :

- le processus persistera à la fermeture de la session ;
- la gestion centralisée des processus.

_forever_ créera autant de processus que vous le désirez tout en fournissant un interface pour redémarrer les services, les arrêter, consulter leur logs ou encore afficher à l'écran l'ensemble processus actifs :

----
$ forever list
info:    Forever processes running
data:        uid  command                  script  pid   logfile           uptime
data:    [0] _sHw /usr/bin/node www.js     15594   15610 /var/log/_sHw.log 0:0:1:59.865
data:    [1] vytX /usr/bin/node api.js     15655   15671 /var/log/vytX.log 0:0:1:38.980
data:    [2] MOrx /usr/bin/node bin/cli.js 15769   15785 /var/log/MOrx.log 0:0:0:57.960
----

Cerise sur le gâteau : une application qui plante sera relancée automatiquement par _forever_.
À vous ensuite d'inspecter les logs d'erreurs et de mettre en place un mécanisme d'alerte pour ne pas faire perdurer ces exceptions.

Toutefois, revers de la médaille : il vous faudra exécuter _forever_ autant de fois qu'une application a de processus à démarrer.

[TIP]
.[RemarquePreTitre]#Outil# forever
====
Une documentation détaillée accompagnée d'exemples est disponible sur le dépôt GitHub du projet :

- [URL]#https://github.com/nodejitsu/forever#
====

_Foreman_ est un programme écrit en Ruby.
Il est destiné à gérer les multiples processus d'une même application. +
C'est l'outil que vous devrez utiliser pour démarrer vos applications sur par la plateforme Heroku après déploiement.

Vos différents processus sont à déclarer dans un fichier `Procfile`, somme toute assez simpliste :

[source]
.Procfile
----
web: node www.js
api: PORT=$PORT node api.js
worker: node bin/cli.js --retries 3
----

Le précédent exemple fait état de trois processus à démarrer, dont certains avec des arguments spécifiques.

La commande suivante démarrera ces trois services, créera deux processus pour le module `api.js` en leur attribuant automatiquement un port différent grâce à :

----
foreman start -c api=2
----

[TIP]
.[RemarquePreTitre]#Outil# foreman
====
D'autres fonctionnalités et paramètres de configuration sont expliqués dans la documentation officielle du projet :

- [URL]#http://ddollar.github.io/foreman/#
====

Il ne nous manque qu'une seule chose désormais : pouvoir démarrer nos processus avec le système d'exploitation, après un démarrage ou redémarrage.
Un bénéfice non-négligeable de l'intégration avec le système d'exploitation est la combinaison avec les outils de monitoring et d'agrégation de logs.

_Upstart_ est l'outil de gestion de processus de la distribution Linux Ubuntu.
Sa configuration est une des plus faciles à apprendre :

[source]
./etc/init/your-app
----
start on startup

exec /usr/bin/node /path/to/your/app.js
----

Cette configuration ultra simpliste décrit la commande à exécuter, et quand lancer automatiquement le service.
Dans ce cas, au démarrage du système.

[TIP]
.[RemarquePreTitre]#Outil# Upstart
====
Une introduction ainsi qu'une documentation détaillée d'_Upstart_ est disponible à l'adresse suivante :

- [URL]#http://upstart.ubuntu.com/cookbook/#
====

L'apprentissage et le débogage de tels scripts peut se révéler fastidieuse et rébarbative … _foreman_ dispose d'une fonctionnalité d'export adressant le problème.
Pensez-y !

Nous avons progressivement outillé l'exécution et la prise en charge de nos applications.
Maintenant intéressons-nous aux impacts de la modification d'une application en service.

==== Modification de l'application

Vous disposez d'une application qui démarre et dont le versionning est mis en place … mais concrètement, on fait quoi quand le code change ?

Cette section s'intéresse aux habitudes à prendre avant de pousser le code modifié dans votre dépôt.

===== Mise à jour des dépendances

L'erreur classique : l'application fonctionne sur votre machine mais pas sur celle de votre collègue.
Un module manque mais vous ne comprenez pas pourquoi …

Ça se résume en deux points :

- vous avez une dépendance installée dans votre projet qui n'est pas déclarée dans le fichier `package.json` ;
- la version de vos dépendances et celle de l'autre personne diffèrent.

La commande npm adresse très exactement ces problèmes grâce aux actions suivantes :

----
npm prune
npm update
----

La première supprimera du répertoire _node_modules_ toute dépendance non-déclarée dans le fichier `package.json`.
La seconde installera les dépendances manquantes et mettra à jour les dépendances locales.

`npm update` se comporte de manière similaire à `npm install` à une différence près : les dépendances préalablement installées seront mises à jour si nécessaire.

Ces deux commandes vous assureront un état d'installation similaire à ce qu'une personne aurait en procédant à une installation _fraîche_.

[TIP]
.[RemarquePreTitre]#npm# EPEERINVALID
====
Il se peut qu'une erreur _EPEERINVALID_ se déclare lors d'une mise à jour ou d'une fraîche installation.

image::{indir}/images/npm-outdated-peerinvalid.png[align="center",scaledwidth="85%"]

Cela signifie qu'un paquet réclame une dépendance d'une version différente et incompatible avec celle que vous déclarer dans votre fichier `package.json`.

Trois solutions s'offrent à vous :

- monter en version sur le module incriminé (dans notre exemple, le module `browserify`) ;
- si la version la plus récente de ce module casse la compatibilité de votre application, sélectionnez une version majeure satisfaisant la condition de compatibilité (ici, `>= 3.20.5`) ;
- en dernier recours, supprimer le contenu de _node_modules_ et tout réinstaller proprement — des fois cela suffit à écarter les conflits de version.
====

===== Exécution des tests

L'écriture de tests et la vérification de la qualité de votre code sont un excellent moyen de vous assurez que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un château de carte : le moindre changement accentue le risque de propager des erreurs dans tous les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un contexte d'exécution dédié aux tests :

----
npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec d'autres actions basées sur un état de réussite des tests :

----
npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run code-quality && npm run unit-tests",
    "code-quality": "jshint src/",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "jshint": "*"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json` tout en bénéficiant d'une indépendance d'exécution de vos commandes.

===== Choisir un bon numéro de version

Bien versionner chaque publication de votre projet n'apporte que des avantages.
Et ce, que vous choisissiez ou non de publier vos modules dans un registre npm public ou privé.

Modifier le numéro de version dans votre fichier `package.json` revient à déclarer deux choses :

1. l'*intention du changement*, à savoir mineur, fonctionnel ou très important ;
2. un `git tag` s'impose, pour marquer l'historique de version et faciliter la *reprise du code à un stade identique* à celui livré en production ou dans le registre npm.

Il est temps d'expliquer la spécification _semver_ pour mieux comprendre en tirer profit.

Un numéro de version suivant la logique _semver_ est structuré en quatre parties : MAJEUR.MINEUR.PATCH-EXTRA.

- *Majeur* : changement important d'API cassant la compatibilité avec les versions majeures précédentes ;
- *Mineur* : changement fonctionnel d'API ne cassant pas la compatibilité avec les autres publications associées à la même version majeure ;
- *Patch* : changement trivial impliquant souvent un simple correctif et n'ayant aucun impact de compatibilité ;
- *Extra* (optionnel) : métadonnée spécifique indiquant le statut (beta, alpha etc.), la cible (architecture de CPU, compilateur visé etc.) ou autre (identifiant de commit, numéro de _build_ ayant généré le paquet etc.).

Autrement dit, si vous modifier le numéro de version de `1.1.1` vers :

- `2.0.0` : incompatibilité de code avec toutes les versions de la branche `1.x` ;
- `1.2.0` : fonctionnalités modifiées mais compatibles avec le reste de la branche `1.x` ;
- `1.1.2` : correctif de la version `1.1.1` ;
- `1.1.2-beta.2` : deuxième version beta du correctif de la version `1.1.1`.

À ce stade, nous sommes dans le déclaratif : chaque projet ajoutant une dépendance vers un autre module _choisit_ sa manière d'accepter les nouvelles versions.

===== Publication du code

Puisque nous utilisons un outil de suivi de version comme Git, il est facile non seulement d'installer le projet sur les machines autorisées.
Mais il est aussi aisé d'utiliser ce même mécanisme pour déclarer notre code comme dépendance d'un autre de nos projets.

Dans le cas où votre module est publié dans un dépôt Git privé, accessible au travers de SSH, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+ssh://git@votre-serveur-git:projet/module.git#branche"
  }
}
----

Seules les personnes ayant un accès SSH à ce dépôt seront à même d'obtenir le code au travers de la commande `npm install`.

Dans le cas où votre module est publié dans un dépôt Git public accessible au travers de HTTP, utilisez la syntaxe suivante :

[source]
.package.json
----
{
  ...
  "dependencies": {
    "votre-module": "git+https://votre-serveur-git/projet/module.git#branche"
  }
}
----

[TIP]
.[RemarquePreTitre]#npm# Mise à jour d'une dépendance Git
====
La commande `npm update` actualise vos dépendances … sauf les dépendances Git.

Pour mettre à jour une dépendance Git, il vous faut recourir à la commande … `npm install`.
====

Enfin, optez pour une publication dans le registre npm si vous considérez votre projet comme étant suffisamment solide et testé pour être partagé avec les communautés Node.

Cette simple commande suffit à déclarer une nouvelle version :

----
npm publish
----

`npm publish` téléversera une archive compressée associée au numéro de version déclaré par le fichier `package.json` et contenant tous les fichiers du projet.
Tous les fichiers sauf ceux correspondant aux motifs déclarés dans les fichiers `.gitignore` et `.npmignore`.

Pour résumer, si le module est nommé `nodebook` et est en version `1.3.0`, `npm publish` enregistrera cette version dans le registre npm.
L'installation du module fraichement publié est accessible à travers ces différentes variantes :

----
npm install nodebook
npm install nodebook@latest
npm install nodebook@1.3.0
----

Utilisez l'installation versionnée pour installer spécifiquement cette version à tout moment :

----
npm install --save-exact nodebook@1.3.0
----

==== Opérations de routine

Votre projet fonctionne de manière autonome.
Mieux encore : il n'y a plus de bug à corriger ni de nouvelle fonctionnalité à apporter pour le moment.

Alors que faire d'une application Node en production avant qu'elle ne prenne la poussière ?

===== Vérifier l'état des dépendances

Maintenir ses dépendances à jour est important pour deux raisons :

- colmater des bugs qui pourraient se répercuter sur votre application ;
- se prémunir de faille de sécurité mettant en danger vos données et votre système informatique.

En dernier recours, vérifier la fraîcheur de ses dépendances permet de prendre connaissance de nouvelles versions majeures ou mineures dont vous pourriez bénéficier.

Quoiqu'il en soit, une commande npm nous aidera une fois de plus à obtenir les informations voulues :

----
npm outdated
----

La lecture de sa sortie peut être déroutante au premier abord, notamment dans le cas d'un module qui n'a pas été mis à jour via `npm update` depuis un moment :

.Résultats obsolètes issue de `npm outdated`
image::{indir}/images/npm-outdated.png[align="center",scaledwidth="85%"]

Le tableau ne liste que les dépendances considérées comme obsolètes en l'état actuel d'installation de votre projet.
Il se peut donc que le résultat varie d'une machine à l'autre, en fonction des versions installées localement. +
Les résultats est divisé en cinq colonnes :

- *Package* : npm du paquet concerné — en jaune une dépendance qui sera satisfaite en cas de `npm update`, en rouge une dépendance qui nécessite une mise à jour manuelle ;
- *Current* : version installée localement — _MISSING_ sera affiché si la dépendance n'est pas encore installée, _git_ indique que la dépendance est installée via git ;
- *Wanted* : version installée après exécution de `npm update` ;
- *Latest* : version la plus récente publiée dans le registre npm ;
- *Location* : emplacement de la dépendance — dépendance directe ou dépendance incluse dans une autre dépendance etc.

[TIP]
.[RemarquePreTitre]#Remarque# Et si une dépendance n'est pas listée ?
====
Toute dépendance listée dans le fichier `package.json` mais absente du tableau est considérée comme à jour.
====

La première action à mener est de procéder à l'exécution de la commande `npm update`, puis de relancer la commande `npm outdated` :

.Résultats `npm outdated` après mise à jour
image::{indir}/images/npm-outdated-wanted.png[align="center",scaledwidth="85%"]

Le résultat est probant : de nombreuses dépendances précédemment listées en rouge on disparu.
Il ne reste que trois dépendances sur lesquelles nous pouvons avoir une action directe en modifiant la version référencées dans le fichier `package.json`.

Pour forcer l'installation de la version correspondant à la colonne _Latest_ de la commande `npm outdated`, il suffit d'utiliser le suffixe `@latest` lors de l'installation :

----
npm install --save-dev grunt-contrib-uglify@latest
----

Et ainsi de suite pour les autres dépendances de premier niveau.
Voici ce qui est affiché après l'installation de nouvelles versions majeures :

.Résultats obsolètes issue de `npm outdated`
image::{indir}/images/npm-outdated-uptodate.png.png[align="center",scaledwidth="85%"]

On ne peut faire mieux en l'état car :

- une dépendance Git apparaîtra systématiquement car npm n'a aucun moyen de connaître s'il s'agit de la dernière version en date ;
- les dépendances de second niveau (et plus) ne sont pas maitrisables si le paquet reposant sur celles-ci est à jour.

[TIP]
.[RemarquePreTitre]#Outil# David
====
L'outil en ligne _David_ se charge de vérifier l'état des dépendances de chaque module publié dans le registre npm.

Le moyen le plus simple étant de souscrire au flux RSS de chacun de vos modules publié dans le registre afin d'être notifié de leur obsolescence.

- [URL]#https://david-dm.org/#
====

===== Éclater sa base de code

Le temps sédimente votre base de code.
Elle grossit, se densifie et devient à chaque fois un peu plus difficile à lire et naviguer.

Plusieurs raisons peuvent vous pousser à extraire une partie de votre code afin de le placer dans un autre module :

- le besoin de partager la logique métier d'une application avec une autre application ;
- une portion de votre application n'est pas spécifique à son métier et gagnerait à devenir autonome ;
- un composant pourrait être partagé et réutilisé dans un contexte  Web ;
- un besoin de clarification des dépendances de votre application ainsi que de leur documentation ;
- les chemins de vos appels à `require()` deviennent longs et compliqués.

C'est quelque chose de facilement identifiable à l'œil nu :

[source,javascript]
----
var User = require('../../lib/model/user.js');
var Validator = require('../app/middlewares/validator');
var csvParser = require('../../lib/parsers/csv');
----

Dans le cas présent, ces trois modules pourrait être extraits dans les modules indépendants suivants :

- *my-app-models* : pour bénéficier d'un module global gérant tous vos modèles de données — la limite se présentera quand vous aurez beaucoup de modèles dont la compatibilité occasionnera des collisions ;
- *my-app-models-user* : pour bénéficier d'un module dédié à la description de la persistence d'un utilisateur ;
- *validator-middleware* : pour bénéficier d'un module de validation générique et disponible dans le registre npm ;
- *csv-parser* : pour bénéficier d'un parseur CSV utilisable dans toutes vos applications — avez-vous pensé à regarder dans le registre npm avant de réinventer la roue ? ;-)

Il s'agit d'une logique de maintenabilité et d'expression des intentions de votre application.
Elle sera plus facile à maintenir si elle rend isole et rend explicite les dépendances entre les différents modules. +
À moins que vous ne soyiez fan du code spaghetti ;-)

===== Alertes de sécurité

Il existe quatre niveaux où des failles de sécurité peuvent s'immiscer :

- votre propre code — des revues de code, une amélioration de vos connaissances et la commande d'audits vous aideront à identifier les possibles failles et vulnérabilités ;
- des vulnérabilités contenues dans vos dépendances, et dépendances de vos dépendances ;
- des vulnérabilités occasionnées par Node ;
- des vulnérabilités occasionnées par V8, dont le développement est indépendant du projet Node.

On n'oubliera pas les vulnérabilités liés à votre système d'exploitation, à ses logiciels ainsi qu'à son exposition au monde extérieur — mais ce n'est pas l'objet de cet ouvrage.

Plusieurs canaux sont à votre disposition pour être notifié très rapidement de mises à jour correctives :

- *Failles de sécurité de modules npm* : [URL]#https://nodesecurity.io/advisories# — et son flux RSS [URL]#https://nodesecurity.io/rss.xml# ;
- *Failles de sécurité de Node* : [URL]#http://blog.nodejs.org/vulnerability/# — et son flux RSS [URL]#http://blog.nodejs.org/feed/vulnerability/# ;
- *Mises à jour de Node* : [URL]#http://blog.nodejs.org/# — et son flux RSS [URL]#http://blog.nodejs.org/feed/#.

=== Bien utiliser npm

Le registre npm fourmille de modules en tous genres.
Ils fournissent de simples fonctions, des librairies ou des _frameworks_ complets pour gérer vos accès réseau, vos bases de données, la qualité de vos projets et leur automatisation.

Mais comment se retrouver dans cette jungle contenant plusieurs dizaines de millier de modules ?

==== Chercher un module

Le site Web du registre npm ([URL]#https://npmjs.org#) est _la_ ressource incontournable.
Le site liste l'intégralité des modules récents, des modules populaires et des auteurs populaires.

Les résultats sont triés en fonction de la correspondance avec l'expression recherchée … ce qui peut se révéler compliqué si vous cherchez avec les mauvais termes ou que vous ne connaissez pas le terme anglo-saxon adapté.

Pour en savoir plus sur la manière de choisir un module, et de séparer le grain de l'ivraie, reportez-vous à la section suivante.

La commande `npm search` est une alternative au site Web.
Son algorithme d'affichage est d'ailleurs identique. +
Astuce : si le motif de recherche est encadré par le caractère `/`, la commande npm effectuera la requête via une expression régulière :

----
npm search /(strings?|format)/
----

Enfin, le projet _npmsearch_ ([URL]#http://npmsearch.com#) est une initiative indépendante dont le but est de proposer une interface optimisée pour la recherche de modules Node.
Ses principaux avantages sont la rapidité d'affichage des résultats, ainsi qu'un tri par défaut orienté sur la *pertinence*.

Cette pertinence est évaluée selon certains des critères évoqués ci-après.

==== Critères de sélection d'un module

La sélection d'un module est un choix subjectif : la qualité, la pertinence et la popularité sont corrélé sans pour autant être des critères impératifs. +
Un module peu populaire sera-t'il moins bon pour autant ? Un module populaire est-il plus performant qu'une alternative ? Un module bien testé est-il plus aisé à utiliser ?

Bref, pour vous aider à choisir — et ce peu importe le contexte — voici une liste subjective de critères et leur impact sur votre processus de décision :

- *documentation* : un fichier _README_ décrivant l'API ou une *documentation technique illustrée d'exemples* sont des exemples d'objectif de qualité aidant tant à l'utilisation qu'à la contribution du-dit module ;
- *badge d'intégration continue* : la présence de tests est indispensable pour assurer une certaine qualité. Le badge d'intégration continue est un mécanisme supplémentaire pour démontrer l'*existence de tests* et leur *automatisation* lors de toute contribution de code ;
- *dépendances* : l'existence de modules reposant sur un autre démontre une *marque de confiance* d'autres développeurs. Confiance suffisante dans la solidité des fondations sur lesquelles ils s'appuient pour bâtir leur propre module ;
- *date de mise à jour* : une ou plusieurs versions majeures de Node sont-elles sorties entre temps ? Si oui, des *risques d'incompatibilité* peuvent se présenter. Certaines dépendances peuvent également être devenues obsolètes ou avoir présenté des failles de sécurité ;
- *maintenance* : si personne ne met à jour le module alors que des contributions se présentent, cela peut se révéler bloquant, dénoter une *obsolescence* d'idée ou impliquer l'existence d'un _fork_ de ce module ;
- *état des contributions* : les mainteneurs répondent-ils aux contributeurs ? Les contributions de code sont-elles acceptées dans des conditions légitimes ? Ou tout simplement, y'a-t'il beaucoup de déclaration de bugs en suspens ? Telles sont les indicateurs de vitalité pour estimer la gravité et la probabilité que la librairie nous explose au visage lorsqu'on ne s'y attendra pas.

.Résultats `npm outdated` après mise à jour
image::{indir}/images/module-npm-ok.png[align="center",scaledwidth="85%"]

.Exemple de module
image::{indir}/images/module-npm-ko.png[align="center",scaledwidth="85%"]

Enfin, n'oubliez pas qu'il s'agit de critères subjectifs.
Les mainteneurs du module ne sont peut-être pas de bons communicants ou n'ont que peu d'expérience en terme de tests … ou ils n'ont tout simplement pas eu le temps. +
N'hésitez pas à les encourager si vos expérimentations se révèlent concluantes.
Contribuez des tests et de la documentation à hauteur de votre temps.
Même s'il ne s'agit _que_ de cinq lignes de code, d'un exemple supplémentaire ou d'une faute d'orthographe en moins.

C'est comme cela que l'écosystème s'améliore petit à petit … et que vous apprenez par la même occasion.

==== Sélection de modules utiles et courants

===== Manipulations diverses
===== Base de données
===== Ligne de commande
===== HTTP et API
===== Préprocesseurs
===== Gestion des dates
===== Templating
===== Tests
===== Automatisation de tâches

==== Auteurs et communautés de confiance

=== Design patterns

==== index.js

==== Globbing

==== Injection de module

==== Callback

==== Event

==== Promesses

==== Streams

==== Bloquant / non-bloquant / synchrone / asynchrone


