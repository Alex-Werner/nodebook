== [chapterNumber]#1# Introduction à Node.js

[.lead]
Node.js génère beaucoup de discussions, d'intérêts et d'envies. +
Dans ce chapitre, nous allons faire le point sur ce qu'est Node.js pour mieux comprendre dans quel cambouis nous allons plonger les mains.

====
.Sommaire
- Comprendre ce qu'est Node.js
- Savoir qui gère Node.js au quotidien
- Décider si Node.js peut compléter ou remplacer un système en place
- Pourquoi autant de _hype_ ?
====

Node.js est-il un langage de programmation ?
Node.js est-il un _framework_ JavaScript ?
Qu'en restera-t'il une fois que la frénésie retombera ?

Ce chapitre n'est pas essentiel à l'apprentissage de Node.js.
Il permet de comprendre pourquoi et comment Node a émergé.
Surtout, il vous permettra de comprendre des choix techniques à l'origine de ses fondations, et en quoi l'utiliser peut vous apporter en contexte personnel ou professionnel.

Qu'on se le dise : *un langage de programmation en lui-même n'a jamais solutionné quelconque problème*.
Cela reste avant tout une affaire de compétences et d'expérience.


=== Node.js : la plateforme JavaScript côté serveur

Node.js n'est pas un langage de programmation. Node.js n'est pas non plus un _framework_ JavaScript. *Node.js est une plateforme de programmation JavaScript*. +
La différence entre ces trois désignations peut sembler subtile, futile voire inutile mais le terme *plateforme* est la véritable nature de Node.

*Exécuter du JavaScript côté serveur n'est pas non plus une révolution*.

L'entreprise _Netscape_ s'y est déjà essayé au début des années 1990 avec _Netscape Enterprise Server_, juste après l'avoir introduit dans son navigateur Web _Netscape Navigator_.

En 1997, _Netscape_ s'est attelée à créer https://www.mozilla.org/rhino/[Rhino], une implémentation de JavaScript en Java disponible sous licence libre.
_Rhino_ était un des projets liés à la réécriture de _Netscape Navigator_ en Java. Si _Netscape_ a depuis fermé ses portes, _Rhino_ a permis l'émergence de projets utiles aux développeurs Web.

D'autres initiatives plus récentes comme http://ape-project.org/[APE (Ajax Push Engine)] ont mis en œuvre JavaScript côté serveur. JavaScript était surtout un choix logique de partage de code entre client et serveur pour Comet, le précurseur des Websockets.

[TIP]
====
.[tip-titre]#Glossaire# Comet
_Comet_ est un terme regroupant les différentes tentatives techniques permettant à un serveur Web d'envoyer des données à un client sans que celui-ci ne les aie demandées initialement.

Parmi ces techniques, on retrouve le _long polling_, consistant à conserver une connexion Ajax ouverte pendant la durée de vie d'une page Web.
====

[TIP]
====
.[tip-titre]#Glossaire# Websockets
_Websockets_ est un protocole basé sur TCP.

Il permet de maintenir une connexion HTTP active entre un client et un serveur et d'y faire transiter les données de manière bi-directionnelle.

Ce protocole sera probablement rendu obsolète par le successeur d'_HTTP 1.1_, à savoir _HTTP 2.0_.
_HTTP 2.0_ a initié par Google en tant que protocole _SPDY_ (prononcer _speedy_).
====

[TIP]
====
.Cas d'utilisation modernes de _Rhino_.
Rhino est toujours utile dès qu'un projet Java implique du JavaScript.

Google l'utilise comme environnement d'exécution de ses http://googleappsdeveloper.blogspot.com/2012/11/using-open-source-libraries-in-apps.html[Google Apps Scripts].
Ces scripts permettent à tout un chacun de développement des extensions et des interactions supplémentaires pour les documents Google Drive.

Rhino est également employé dans http://yui.github.io/yuicompressor/[yuicompressor], un optimiseur CSS et JavaScript créé par Yahoo.
_yuicompressor_ est tombé en désuétude suite au gain de popularité de http://gruntjs.com/[Grunt].
Ce dernier est écrit en JavaScript et repose sur … Node. +
La boucle est bouclée.
====

Node représente un *environnement d'exécution* (_runtime_), un  *ensemble d'APIs JavaScript* ainsi qu'une *machine virtuelle JavaScript* performante (parseur, interpréteur et compilateur) pouvant accéder à des ressources systèmes telles que des fichiers (_filesystem_) ou des connexions réseau (_sockets_).

Typiquement, une personne développant en Node écrit du code se basant sur les APIs à disposition. Ce code est lu par le _runtime_ Node qui le transmet à la VM JavaScript. VM qui traduit le programme en langage machine (_bytecode_) avant d'être effectivement exécuté par le processeur.

Pour comprendre comment Node a opté pour cette approche, retournons en 2009, lorsque son créateur **Ryan Dahl** cherchait à résoudre élégamment un problème de performance de programmation.

=== Historique du projet Node.js

En 2006, _Ryan Dahl_ est un étudiant Américain en troisième année de doctorat de mathématiques.
Si le but initial était de devenir professeur de mathématiques, il prend la décision de ne pas terminer sa thèse et entreprend un voyage au Chili.

Alors qu'il cherche à effectuer des petits boulots, il y rencontre un autre Américain développant des sites Web.
Ruby on Rails connait un succès grandissant et attire son attention.
Alors que Ryan considérait utiliser Rails, il découvre avec horreur la lenteur du _framework_ et cherche à en analyser les origines.

Ryan débute alors sa *quête des applications Web performantes* et découvre _Mongrel_, un serveur HTTP écrit en Ruby.
Il est séduit par deux choses :

- la possibilité d'*inclure* un serveur HTTP comme librairie applicative ;
- la simplicité de fonctionnement : recevoir une requête HTTP et décider soi-même de la réponse à apporter.

La quête initiale se dirige désormais sur la possibilité de créer *un serveur Web non-bloquant*.
En d'autres termes, un serveur capable dans un même processus de traiter d'autres requêtes en attendant de renvoyer la réponse initiale.

Nous sommes alors en 2008 et le site de partage de photos Flickr  innove avec un nouveau système d'upload d'images.
Ce système remplace la sensation de page figée par une … *barre de progression*.

[.text-center]
image:http://farm6.staticflickr.com/5117/7112862941_3b8c8e9916_o_d.png[] Nouvelle et ancienne interface d'upload de Flickr.

> http://code.flickr.net/2008/04/22/making-a-better-flickr-web-uploadr-or-web-browsers-arent-good-at-uploading-files-by-themselves/ (reclasser autrement)

C'est le *déclic* pour Ryan : _Mongrel_ avait déjà un plugin pour ça mais il fallait que ça soit encore plus simple pour le développeur.
Il reproduit le mécanisme avec succès en C.
Les développeurs Web jugeant la solution trop complexe, Ryan tente la même approche avec d'autres langages comme Python, Lua ou même Haskell.
Il se heurte au sempiternel des ressources bloquantes des différents interpréteurs.

Le deuxième *déclic* se produit en janvier 2009 lorsque _JavaScript_ émerge dans une discussion entre développeurs.
_Eurêka_ !
La machine virtuelle JavaScript V8 de Google a été libérée en _Open Source_ depuis quelques mois et Apple, Microsoft, Mozilla et Google se battent pour rendre la pierre angulaire JavaScript toujours plus performante.

Ryan admet que JavaScript dispose des caractéristiques idéales même s'il n'est pas un adepte du langage : fonctions anonymes, _closures_ et l'_event loop_ (dans le DOM en tous cas).
Il lui manque juste la capacité d'accéder à des _sockets_, au système de fichiers et à d'autres fonctions systèmes.

Il quitte alors son travail, s'inspire de ses travaux de modules non-bloquants pour Ngninx et se concentre pendant six mois à marier JavaScript, V8 et l'environnement système : Node.js. +
Sa démonstration de serveur IRC écrit en 400 lignes de JavaScript lors de la conférence JSConf Europe suscite l'enthousiasme et attire l'attention.

L'entreprise américaine _Joyent_ l'embauche à plein temps pour continuer le développement de Node.
Ils pressentent que la plateforme Node répond à leurs projets de _datacenter_ et d'hébergement.

*Node et sa communauté sont nés* et ont continué à prospérer depuis lors.
Pour une simple affaire de _barre de progression_ et une obsession de _perception de rapidité_.

[TIP]
====
.[tip-titre]#Vidéo# _History of Node.js_
La vidéo suivante est une vidéoconférence donnée par Ryan Dahl, le créateur de Node au cours de l'année 20011.
C'est la première fois qu'il intervient pour expliquer son parcours et la genèse du projet.

Peut-être un élément qui figurera dans les livres d'histoire !

- http://www.youtube.com/watch?v=SAc0vQCC6UQ
====

=== Les raisons du succès

En 2009, la tension et l'attention autour de JavaScript sont énormes.
La mode du tout _Ajax_ et des _mashups_ s'est estompée mais une chose en est ressortie : JavaScript n'a plus à rougir ni à être relégué au rang de sous-langage.
Les initiatives JSlint, CommonJS et les _good parts_ de Douglas Crockford y sont pour beaucoup dans la création de code élégant.

D'un autre côté, les entreprise développant des navigateurs Web se livrent à féroce compétition d'optimisation.
Google, Mozilla et Apple ont en effet besoin de navigateurs rapides pour améliorer leurs parts de marché sur les ordinateurs mais aussi les téléphones et tablettes.
On peut considérer que JavaScript est à cette époque le langages de programmation bénéficiant du plus grand investissement financier et humain en R&D.

La communauté JavaScript accueille avec ferveur Node lors de la conférence JSConf Europe en 2009.
Elle contribue à son amélioration et à la création d'un écosystème de modules réutilisables.

Il faudra attendre la création du registre `npm` au tout début 2010 pour faciliter encore plus l'installation et le partage des modules Node autour du globe.
Dès lors, un simple `npm install node-playground` suffit pour inclure le module `node-playground` à son propre projet.
Partager un module est tout aussi simple puisqu'un simple `npm publish` le rend disponible à tous en un instant.

npm devient une telle pierre angulaire qu'il est inclut par défaut dans l'installation de Node à partir de novembre 2011, lors de la publication de Node 0.6.3.
La communauté Node et ses contributeurs ont fait le reste du travail en fournissant un écosystème de modules riche et variés : frameworks, templating, drivers de bases de données, serveurs HTTP, serveurs Websockets, préprocesseurs CSS, CoffeeScript, parseurs, proxy, serveurs de log, librairies de tests, langages de _templating_ etc.

Malgré ses défauts de jeunesse, Node réussit également le tour de force de la performance : la recette de l'accès non-bloquant aux ressources aurait-elle fonctionné ?
À en croire les personnes ayant migré vers Node pour ces raisons, la réponse est *oui*.

=== Pourquoi choisir Node.js ?

Il y a plusieurs raisons d'utiliser Node, en complément ou remplacement d'un langage existant.
Il est préférable que cela soit avant tout une *volonté ou une curiosité et que cela se fasse en considérant la plate-forme Node pour ce qu'elle est* et non pour ce que vous voudriez qu'elle soit.

Si l'on tient compte des raisons historiques de la création de Node, il est évident que Node est tout désigné dès lors que l'on parle d'*applications à nombreuses actions concurrentes*. +
Autrement dit, dès que plusieurs requêtes impliquent des accès réseau, aux fichiers ou au système.

Grâce aux _streams_, Node est également un excellent choix pour *travailler et transformer de gros flux de données* en utilisant peu de mémoire. +
Cela concerne aussi bien la lecture de fichiers CSV, JSON ou XLM de plusieurs giga-octets ou la lecture en continu de l'API Twitter ou Facebook.

La compatibilité de Node avec les modules CommonJS incite à concevoir de multiples modules respectant le _principe de responsabilité unique_. +
Node encourage ainsi à créer de *multiples applications autonomes et modulaires au lieu d'une seule application monolithique*.

Avec Grunt et Gulp, les développeurs verront dans Node leur *compagnon idéal pour compiler, générer, assembler et minifier* leurs différents fichiers. +
Le bénéfice évident est le partage du même outillage CSS, JavaScript et HTML entre développeurs, par projet.
Finies les ambigüités … et place à l'automatisation !

Conséquence directe du point précédent, Node peut se révéler être une opportunité pour *unifier vos équipes de développement _frontend_ et _backend_*. +
Node devient un langage commun entre les individus.
Ils peuvent se focaliser sur des fonctionnalités indistinctement de leur périmètre, qu'il s'agisse du navigateur, du serveur ou d'une API.

Enfin, Node est un *environnement adapté à l'apprentissage et l'amélioration des connaissances en JavaScript*. +
Vous disposez de la maitrise de la version de Node, des modules employés et n'avez pas à vous soucier de quelconque compatibilité de version de JavaScript.
 
=== Pourquoi éviter Node.js ?

S'il y a des raisons d'utiliser ou d'adopter Node, l'inverse est également vrai.
Il faut toutefois noter que la majorité des raisons sont liées à une _culture_ et des _compétences_ déjà en place dans un environnement donné.

Ce serait d'ailleurs la première et principale raison de ne pas utiliser Node ; si votre équipe dispose déjà de fortes compétences, d'habitudes et d'aisance dans un autre langage. +
Il n'y a pas de raison d'utiliser Node *si vous parvenez à un résultat similaire avec des performances comparables*.

L'*offre logicielle est également à prendre en compte* : CMS, systèmes e-commerce ou autre application prête à l'emploi que la communauté Node n'offrirait pas. +
En 2014, on dénombrait encore peu d'applications de ce genre et pour cause : l'emphase est aux modules à assembler soi-même.

Un facteur important et souvent oublié est *l'acceptation et la compréhension de l'utilisation de Node* par une ou plusieurs équipes.
Il est alors plus intéressant de comprendre les raisons d'un blocage que de forcer ou d'imposer Node. +
Il s'agit peut-être de peu : balayer des idées reçues, animer un atelier technique ou inviter un expert pour répondre aux questions, interrogations et utilité d'un tel changement.

Node n'est pas forcément une solution adaptée si *vos besoins de performance dépassent les capacités de Node*. Certains cas de très haute performance nécessitent d'être au plus près du système ou utilisent fortement le CPU. +
Un langage comme C sera certainement davantage approprié.
Toutefois des solutions comme `node-gyp` vous offrent un accès bas niveau aux éléments internes de la plateforme Node.

Node ne vous aidera probablement pas si vous cherchez à *réaliser des choses qui sera compliquées de par la nature de JavaScript*, à savoir des opérations mathématiques de très haute précision. +
Des modules comme `bignumber.js` peuvent palier le problème.
Il se peut que votre cas de figure ne soit pas couvert ni par Node ni par un des modules de l'écosystème npm.

Enfin si vous croyez que Node va *résoudre des problèmes de compétences en développement* ou résoudre _de facto_ une erreur de conception logicielle, c'est bien évidemment une erreur.

=== L'écosystème Node.js

==== Joyent

==== Registre npm

==== Nodejitsu

==== Node Security Project

=== Qui gère Node.js ?