:nodeVersion: v0.10
:nodeNextVersion: v0.12
:es: ECMAScript 5
:esNext: ECMAScript 6
:imagePath: 02-first-steps
:revisionYear: 2014

== [ChapitreNumero]#2# Premiers pas avec Node.js

On aura beau discuter de Node et de son architecture, rien ne vaut quelques lignes de code pour mesurer ce à quoi nous avons affaire.

Ce chapitre contient tout ce qu'il faut savoir pour installer Node et développer son premier programme avec de bons _design patterns_.

====
.Sommaire
- Installer Node.js
- Comprendre le vocabulaire JavaScript à disposition
- Écrire son premier programme Node.js
- Utiliser des modules tiers
- Apprendre les bons _design patterns_
====

Il est fortement recommandé d'utiliser un interpréteur de commandes (terminal ou _shell_). Les systèmes d'exploitation modernes en proposent un, y compris les versions récentes de Windows.

Si vous n'utilisez pas encore de terminal, voici une liste de recommandations non exhaustive pour vous aider :

- *OS X* : iTerm2, Terminal.app ;
- *Linux* : GNOME Shell, Terminator ;
- *Windows* : PowerShell, Console.

.Terminal iTerm2 sous OS X.
image::{imagePath}/terminal.png[align="center",scaledwidth="85%"]

Tous les exemples de ce chapitre sont relatifs à la *branche {nodeVersion} de Node*. +
Il se peut qu'une nouvelle branche stable soit sortie depuis l'édition de cet ouvrage, par exemple la {nodeNextVersion}.
Il suffit d'adapter les numéros de version adéquats dans les différents exemples. 

=== Préparer son environnement

Installer Node n'est pas très compliqué.
Il existe cependant plusieurs mécanismes d'installation.
Ces mécanismes vont du téléchargement d'un installateur à une compilation manuelle _via_ un terminal.

Voici mes recommandations pour savoir quelle solution d'installation choisir :

- *néophyte ou pressé(e)* : installateur du site nodejs.org, paquet fourni par le système d'exploitation ;
- *vous commencez à maîtriser* : Node Version Manager ;
- *à l'aise avec un terminal* : Node Version Manager ;
- *envie ou besoin de mettre en production* : Node Version Manager ;
- *besoin très spécifique et pointu* : compiler depuis les sources.

Une fois l'étape de l'installation terminée, la suite du livre ne fera plus de distinction entre les différents systèmes d'exploitation : c'est Node qui se chargera des abstractions !

==== Pour les différents systèmes d'exploitation

Certains systèmes d'exploitation fournissent leur propre mouture de Node.
Les procédures les plus courantes sont décrites ci-après.

Une liste complète mais non exhaustive est mise jour sur le wiki du dépôt GitHub de Node à cette adresse : [URL]#https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager#.

Si malgré tout votre système n'y était pas listé, le mieux reste encore d'*utiliser un binaire*, de *compiler depuis les sources* ou de demander à votre *moteur de recherche* favori !

[TIP]
.[RemarquePreTitre]#URL# Téléchargements officiels
====
Les installateurs, les binaires et les sources de Node sont disponibles sur le site officiel [URL]#nodejs.org#. +
Si vous vous sentez perdu(e), téléchargez l'installateur adapté, ouvrez un terminal et sautez quelques pages pour plonger dans l'utilisation de Node.

- http://nodejs.org/download/
====

===== Linux

Node est disponible dans les dépôts des systèmes suivants :

- *Gentoo* : `emerge nodejs`
- *Ubuntu >= 12.04*, *Debian >= jessie*, *Mint* : `sudo apt-get install nodejs`
- *Fedora >= 18* : `sudo yum install nodejs npm`
- *Arch Linux* : `pacman -S nodejs`
- *FreeBSD*, *OpenBSD* : `pkg install node`

Si votre système d'exploitation ne dispose pas de paquet pour Node, essayez dans l'ordre :

1. _Node Version Manager_ (voir ci-après) ;
2. le téléchargement du binaire Node sur son site officiel ;
3. la compilation manuelle de Node.

===== OS X

_OS X_ ne dispose pas de gestionnaire de paquet par défaut.
Quelques projets populaires permettent toutefois d'y remédier :

- *homebrew* : `brew install node`
- *MacPorts* : `port install nodejs`

Si vous n'utilisez aucun de ces gestionnaires de paquet, dans ce cas essayez :

1. _Node Version Manager_ (voir ci-après) ;
2. le téléchargement du binaire Node sur son site officiel ;
3. la compilation manuelle de Node.

===== Windows

Le moyen le plus simple d'installer Node sous Windows est de *télécharger l'installateur officiel* depuis la page de téléchargements de Node.

Toutefois si vous utilisez déjà un gestionnaire de paquet, voici quelques recommandations :

- *scoop.sh* : `scoop install nodejs`
- *Chocolatey* : `cinst nodejs.install`

===== Raspberry Pi

Node a effectué des changements dans son architecture dans sa version 0.8.
Ces changements ont permis d'éviter la compilation systématique sur des architectures processeur autre que l'Intel x86.

Des binaires et installateurs sont de ce fait disponibles pour Raspberry Pi, à base de processeur _ARM_, et très probablement pour d'autres plates-formes de ce genre.

Des binaires et instructions sont disponibles à cette adresse [URL]#https://gist.github.com/adammw/3245130#. +
Un paquet `deb` est également proposé pour les utilisateurs du système d'exploitation _Raspbian_.

.Installation de la dernière version stable de Node sur un Raspberry Pi sous _Raspbian_.
----
wget http://node-arm.herokuapp.com/node_latest_armhf.deb
sudo dpkg -i node_latest_armhf.deb
----

==== Node Version Manager

_Node Version Manager_ est un logiciel permettant de gérer plusieurs versions de Node en même temps, sur une même machine.
Il est communément abrégé en _nvm_.

_nvm_ est l'équivalent de _rvm_ dans le monde Ruby, de _phpenv_ dans le monde PHP ou encore de _virtualenv_ pour Python.

.Installation de _nvm_ et de Node {nodeVersion}.
----
curl https://raw.github.com/creationix/nvm/v0.4.0/install.sh | sh
nvm install 0.10
nvm alias default 0.10   <1>
----
<1> La version par défaut est désormais la dernière version stable de Node {nodeVersion}.

Les instructions d'installation à jour se trouvent sur [URL]#https://github.com/creationix/nvm#.

[TIP]
.[RemarquePreTitre]#Alternative# _n_
====
_n_ est une alternative à _nvm_ écrite en… JavaScript.
Elle a l'avantage d'être compatible avec tous les systèmes d'exploitation compatibles avec le Shell Unix _Bash_.

- https://www.npmjs.org/package/n
====

[TIP]
.[RemarquePreTitre]#Alternative# Et pour Windows ?
====
_nvm_ ne fonctionne pas sur les ordinateurs équipés de Windows.
Il existe deux autres alternatives : _nvmw_ et _nodist_.

_nvmw_ nécessite d'avoir Git et Python tandis que _nodist_ se base uniquement sur Node.
Dans les deux cas, leur installation est très simple.

- https://github.com/hakobera/nvmw
- https://github.com/marcelklehr/nodist
====

==== Compiler depuis les sources

Certaines situations exigeront que vous compiliez Node.
Ce sera le cas si vous cherchez à tirer parti au maximum des instructions de votre CPU ou si aucun binaire n'est disponible pour votre plate-forme.

La compilation manuelle requiert la présence de _GCC_ 4.2+, de _Python_ 2.6+ et de _GNU Make_ 3.81+. +
La procédure de compilation ressemble fortement à ceci :

.Étapes de compilation de Node
----
wget http://nodejs.org/dist/latest/node-v0.10.26.tar.gz
tar -zxf node-v0.10.26.tar.gz
cd node-v0.10.26
./configure && make && make install
----

Les instructions pouvant varier fortement d'un système d'exploitation à l'autre, consultez les dépendances et instructions complètes à cette adresse [URL]#https://github.com/joyent/node/wiki/installation#.

=== Outils de développement

Programmer pour Node revient dans la majorité des cas à écrire du JavaScript.
Donc même si un éditeur texte suffit, il est intéressant de connaître l'offre en outillage autour de Node.

Les logiciels présentés dans les pages suivantes couvrent un large spectre de besoins : écriture du code, coloration syntaxique, inspection dynamique, débogage, productivité et intégration à l'écosystème Node. 

Ceci a pour but de vous aider à piocher au plus près de vos goûts, à défaut de continuer à utiliser votre logiciel habituel.

==== WebStorm

_WebStorm_ est un environnement de développement _(IDE)_ commercialisé par la société _JetBrains_.
Il est dédié au développement web, ce qui inclut JavaScript, Node, mais aussi CSS et HTML.

_JetBrains_ est une entreprise connue dans d'autres écosystèmes pour ses _IDE_ _Pycharm_ (pour Python) et _IntelliJ IDEA_ (pour Java).

_WebStorm_ est compatible Windows, Linux et OS X.
Ses forces résident dans sa relative légèreté (en comparaison à son concurrent _Eclipse_), une auto-complétion intelligente prenant en compte les modules CommonJS et AMD, une intégration des outils populaires dans l'écosystème Node (npm, JSHint, Mocha, Karma, Grunt, Bower etc.) et un débogage avancé.

[TIP]
.[RemarquePreTitre]#Lien# Site officiel
====
Le site officiel de _WebStorm_ met à disposition une documentation lisible et complète ainsi que des vidéos illustrant les fonctionnalités clés du logiciel.

Le téléchargement du logiciel inclut une période d'essai de 30 jours.

- http://www.jetbrains.com/webstorm/
====

image::{imagePath}/webstorm.png[align="center",scaledwidth="85%"]

[TIP]
.[RemarquePreTitre]#Astuce# Licence open source.
====
L'éditeur de _WebStorm_, _JetBrains_, propose une licence gratuite sous réserve d'une contribution active à un projet open source.
====

==== SublimeText

TBD.

- http://sublimecodeintel.github.io/SublimeCodeIntel/
- https://sublime.wbond.net/search/node.js
- http://www.sublimetext.com/

[WARNING]
====
Rajouter une image similaire à Webstorm.
====

==== Brackets

TBD.

- http://brackets.io/
- https://brackets-registry.aboutweb.com/

[WARNING]
====
Rajouter une image similaire à Webstorm.
====

==== vim

TBD.

- http://www.vim.org/
- https://github.com/moll/vim-node
- https://github.com/Valloric/YouCompleteMe
- https://github.com/joyent/node/wiki/Vim-Plugins


[WARNING]
====
Rajouter une image similaire à Webstorm.
====

==== Visual Studio

TBD.

- http://www.visualstudio.com/
- https://nodejstools.codeplex.com/

[WARNING]
====
Rajouter une image similaire à Webstorm.
====

=== Node, JavaScript et ECMAScript

Nous l'avons vu dans le premier chapitre, Node utilise JavaScript comme principal langage de développement.
Mais contrairement à Ruby, Python ou PHP dont le numéro de version annonce les fonctionnalités exploitables, qu'en est-il de Node et de JavaScript ?

Il faut se tourner du côté de _V8_ pour savoir ce que la machine virtuelle est capable de comprendre.
Et comme chaque version de Node est associée à une version spécifique de _V8_, il suffit d'aller regarder les notes de version de V8 pour l'apprendre.

De manière générale, _V8_ implémente les spécifications approuvées ou en passe d'être approuvées par le comité gérant l'évolution du langage JavaScript : le *TC39*.

Enfin si vous n'avez pas envie de retourner la moitié du Web pour savoir si _V8_, donc Node, supporte telle ou telle fonctionnalité, partez du principe que *le JavaScript supporté par Chrome ou Opera correspond au JavaScript supporté par Node*.

[TIP]
.[RemarquePreTitre]#FAQ# JavaScript ou ECMAScript ?
====
On peut lire régulièrement les termes _JavaScript_ et _ECMAScript_ comme s'il s'agissait de la même chose, y compris dans cet ouvrage.
*JavaScript et ECMAScript sont la même chose*.

JavaScript a été inventé en 1995 par Brendan Eich alors qu'il était employé de la société _Netscape Communications_.
Microsoft lui emboîte le pas en incluant JavaScript dans son logiciel Internet Explorer, alors en version 3.
Pour des raisons de droits de marque, il y est dénommé _JScript_.

La spécification est ensuite validée par l'organisme _Ecma International_ en juin 1997 sous le nom d'_ECMAScript_, standard ECMA-262.

L'utilisation du terme _JavaScript_ est resté dans le vocabulaire courant. Mais c'est bien d'_ECMAScript_ dont on parle, vraiment.

Adobe Flash utilise un dérivé d'ECMAScript, ActionScript et bien des machines virtuelles sont capables d'interpréter partiellement ou intégralement ECMAScript : Rhino en Java, Konq, BESEN en Object Pascal ou encore Esprima en… ECMAScript.
====

La suite de l'ouvrage emploie principalement le terme _ECMAScript_.

==== Standard ECMA-262 Edition 5

ECMAScript a été standardisé dans sa version 5 en décembre 2009.
Il s'agit de la version d'ECMAScript supportée dans Node {nodeVersion}.
La révision 5.1 de juin 2011 est une correction mineure de la spécification.

Il s'agit d'une évolution majeure, dix après sa précédente édition, ECMAScript 3.

_{es}_ introduit le mode strict limitant fortement les effets de bord indésirables, de nouvelles fonctionnalités pour `Object` et `Array`, le support natif de _JSON_ et `Function.prototype.bind`.

Un récapitulatif des fonctionnalités d'{es} est présenté  ci-après.

[TIP]
.[RemarquePreTitre]#Lien# Le futur d'ECMAScript : ES6.
====

_ES6_ est l'abréviation employée pour désigner {esNext}.
_Harmony_ est un des noms de code donné à cette future version d'ESCMAScript, avant que le numéro 6 ne devienne le numéro de version attribué à cette édition.

Ce site référence l'état de l'implémentation d'{esNext} sur différentes plates-formes, dont Node :

- http://kangax.github.io/es5-compat-table/es6/#node
- http://kangax.github.io/es5-compat-table/es6/#nodeharmony
====

==== Rappel des primitives ECMAScript

Un des conforts apporté par l'utilisation d'ECMAScript dans Node est qu'il n'y a pas à se soucier de la compatibilité navigateur : vous pouvez utiliser le meilleur de JavaScript !

Ce résumé des primitives et fonctionnalités principales d'_{es}_ a pour but de vous apprendre ou rappeler la syntaxe à disposition pour écrire des programmes pour Node.

===== String

Chaque élément d'une chaîne de caractère est encodé au format UTF-16 et peut donc contenir 16 bits de données.

L'opérateur `typeof` permet d'identifier une chaîne :

[source,javascript]
----
typeof 'Eyrolles'; <1>
----
<1> Retourne `'string'`.

On peut connaître la longueur d'une chaîne via son attribut `length`.

[source,javascript]
----
'I ♥ JavaScript'.length; <1>
----
<1> Retourne `14`.

On peut nettoyer les espaces englobant une chaîne avec la méthode `trim` :

[source,javascript]
----
'  w w w  '.trim(); <1>
----
<1> Retourne `'w w w'`.

On peut connaître la position d'un ou plusieurs caractères via la méthode `indexOf` :

[source,javascript]
----
'I ♥ JavaScript'.indexOf('JavaScript'); <1>
'I ♥ JavaScript'.indexOf('I'); <2>
'I ♥ JavaScript'.indexOf('?'); <3>
----
<1> Retourne `4` ;
<2> Retourne `0` ;
<3> Retourne `-1`, aucune occurrence n'ayant été trouvée.

On peut collecter les occurrences correspondantes à un masque de caractères via la méthode `match` :

[source,javascript]
----
'I ♥ JavaScript'.match('♥'); <1>
'I ♥ JavaScript'.match(/\wa/g); <2>
'I ♥ JavaScript'.match('!'); <3>
----
<1> Retourne `['♥']` ;
<2> Retourne `['Ja', 'va']` ;
<3> Retourne `null`.

On peut remplacer les occurrences correspondantes à un masque de caractères via la méthode `replace` :

[source,javascript]
----
'I ♥ JavaScript'.replace('♥', 'love'); <1>
'I ♥ JavaScript'.replace(/[A-Z]/g, function(char){
  return char.toLowerCase();
}); <2>
----
<1> Retourne `'I love JavaScript'` ;
<2> Retourne `'i ♥ javascript'`.

===== Number

Tous les nombres en ECMAScript sont des flottants respectant le standard _IEEE 754_.
Un nombre peut donc contenir 64 bits de données, comme en Python et PHP, entre autres.

L'opérateur `typeof` permet d'identifier un nombre :

[source,javascript]
----
typeof 42; <1>
typeof 13.37; <1>
typeof NaN; <2>
----
<1> Retourne `'number'` ;
<2> Retourne également `'number'`, ce qui est souvent source de confusion.

On peut effectuer des opérations mathématiques grâce aux opérateurs `+` (addition), `-` (soustraction), `*` (multiplication), `/` (division) et `%` (modulo).

L'exception dont il faut se méfier est l'addition, car le signe `+` est également l'opérateur de concaténation de chaîne. +
Dès qu'une chaîne est détectée, l'opération d'addition est remplacée par une concaténation.

[source,javascript]
----
1 + 2; <1>
'1' + 2; <2>
1 + '2'; <2>
undefined + 2; <3>
----
<1> Retourne `3` ;
<2> Retourne `'12'` ;
<3> Retourne `NaN`.

Les fonctions `parseInt` et `parseFloat` permettent de respectivement de convertir en nombre entier et nombre flottant :

[source,javascript]
----
typeof 2.10 === 'number';
typeof '2.10' === 'string';

parseInt('2.10', 10); <1>
parseFloat('2.10', 10); <2>
----
<1> Retourne `2` ;
<2> Retourne `2.10`.

La méthode `isNaN` permet d'être sûr de ne pas manipuler un nombre indésirable :

[source,javascript]
----
Number.isNaN(undefined + 1); <1>
Number.isNaN(2.10); <2>
Number.isNaN(undefined); <2>
----
<1> Retourne `true` ;
<2> Retourne `false`.

Il également possible de choisir le nombre de nombres après la virgule avec la méthode `toFixed`. +
Attention toutefois, la valeur retournée est de type `String` :

[source,javascript]
----
10.0101.toFixed(2); <1>
10.0101.toFixed(0); <2>
parseInt(10.0101, 10); <3>
----
<1> Retourne `'10.01'` ;
<2> Retourne `'10'` ;
<3> Retourne `10`.

===== Date

L'opérateur `typeof` ne permet pas d'identifier une date. Il convient d'utiliser `instanceof` :

[source,javascript]
----
typeof (new Date('2014-03-24')); <1>
(new Date('2014-03-24 13:37')) instanceof Date; <2>
typeof Date.parse('2014-03-24 13:37'); <3>
----
<1> Retourne `'object'` ;
<2> Retourne `true` ;
<3> Retourne `'number'`, car il s'agit d'une date exprimée en millisecondes depuis le 1er janvier 1970 (temps _EPOCH_).

Il également possible d'obtenir la date actuelle exprimée en millisecondes avec `Date.now` :

[source,javascript]
----
Date.parse(new Date()); <1>
Date.now(); <2>
----
<1> Retourne `1397381941000` ;
<2> Retourne `1397381941031`, équivalent à la syntaxe précédente donc, la précision à la milliseconde près en plus.

===== Array

L'opérateur `typeof` ne permet pas d'identifier un tableau. Il faut pour cela privilégier la méthode `isArray` :

[source,javascript]
----
typeof []; <1>
Array.isArray([]); <2>
----
<1> Retourne `'object'` ;
<2> Retourne `true`.

Il est possible de connaître la longueur d'un tableau en utilisant la propriété `length` :

[source,javascript]
----
[1, 2, 3].length; <1>
----
<1> Retourne `3` ;

La méthode `join` permet de concaténer tous les éléments d'un tableau avec le séparateur de votre choix :

[source,javascript]
----
[1, 2, 3].join(', ')+'… soleil'; <1>
----
<1> Retourne `'1, 2, 3… soleil'`.

À l'inverse, la méthode `concat` permet de concaténer d'autres éléments dans le tableau courant :

[source,javascript]
----
[1, 2].concat(3); <1>
[1, 2].concat([3, 4]); <2>
[1, 2].concat([3, 4], [5, 6]); <3>
----
<1> Retourne `[1, 2, 3]` ;
<2> Retourne `[1, 2, 3, 4]` ;
<3> Retourne `[1, 2, 3, 4, 5, 6]`.

La fonction de tri via la méthode `sort` se base sur des comparaisons positives, négatives ou neutres pour retourner un nouveau tableau, réindexé :

[source,javascript]
----
[1, 3, 2].sort(function ascSort(a, b){
  return a - b;
}); <1>

[1, 3, 2].sort(function descSort(a, b){
  return b - a;
}); <2>

['A', 'b', 'c', 'a'].sort(function ascSort(a, b){
  return (a < b) ? -1 : ((a > b) ? 1 : 0); 
}); <3>
----
<1> Retourne `[1, 2, 3]` ;
<2> Retourne `[3, 2, 1]` ;
<3> Retourne `['a', 'A', 'b', 'c']`.

Les méthodes suivantes sont des nouveautés d'ECMAScript 5.
Elles facilitent énormément les itérations sur les tableaux tout en ajoutant une orientation fonctionnelle pas désagréable du tout.

La méthode `map` permet de retourner un nouveau tableau avec des valeurs modifiées :

[source,javascript]
----
['a', ' B', 'c '].map(function(value){
  return value.trim().toUpperCase();
}); <1>
----
<1> Retourne `['A', 'B', 'C']`.

La méthode `filter` quant à elle retourne un nouveau tableau ne contenant que les éléments retournant une _valeur positive_ :

[source,javascript]
----
var values = [1, 'a', 120, undefined, 4];
values.filter(function smallerThanTen(value){
  return value < 10;
}); <1>
----
<1> Retourne `[1, 4]`.

De manière similaire, les méthodes `some` et `every` retournent un booléen si _au moins une itération_ et _toutes les itérations_ ont renvoyé une _valeur positive_ :

[source,javascript]
----
var values = [1, 'a', 120, undefined, 4];
var isUndefined = function(value){
  return value === undefined;
};

values.some(isUndefined); <1>
values.every(isUndefined); <2>
[undefined, undefined].every(isUndefined); <3>
----
<1> Renvoie `true` puisqu'au moins une valeur équivaut à `undefined` ;
<2> Renvoie `false` puisque toutes les valeurs n'équivalent pas à `undefined` ;
<3> Renvoie `true` puisque toutes les valeurs sont égales à `undefined`.

La méthode `reduce` a un comportement similaire à `sort` mais fonctionne de manière accumulative :

[source,javascript]
----
var pairs = [[1, 2], [3, 4], [5, 6]];

pairs.reduce(function sumItAll(left, right){
  return left + right[0] + right[1];
}, 0); <1>

pairs.reduce(function pairSum(left, right){
  left[0] += right[0];
  left[1] += right[1];
  return left;
}, [0, 0]); <2>
----
<1> Retourne `21` ;
<2> Retourne `[9, 12]` ;

[TIP]
.[RemarquePreTitre]#FAQ# Tableau non contigü.
====
Il se peut que des valeurs soient manquantes dans un tableau.
On dit alors que les valeurs ne sont pas contigües.

Cela affecte les fonctions itératives et peut se révéler problématique si vous cherchez à conserver cette absence de valeurs :

----
var a = [1,, 3, undefined, null];
var print = function(value){ console.log(value); };

a.length; <1>
a.forEach(print); <2>
----
<1> Retourne `5` ;
<2> Affiche 4 valeurs : `1`, `3`, `undefined` puis `null`.
====

===== Object

Dans ECMAScript, tout est objet. C'est le _prototype_ qui détermine le comportement dudit objet.
Les objets peuvent être créés de manière littérale, avec la fonction `Object.create` ou via un constructeur.

[source,javascript]
----
var litteral = { literally: 'lateral' };
var litteralCopy = litteral;
var constructed = new Date();
var objectCreated = Object.create(litteral);

litteral.literally; <1>
objectCreated.literally; <2>
litteral === litteralCopy; <3>
litteral === objectCreated; <4>
----
<1> Retourne `'lateral'` ;
<2> Retourne également `'lateral'` ;
<3> Retourne `true`, les deux objets étant la même instance ;
<4> Retourne `false`, les deux objets étant deux instances différentes.

L'opérateur `typeof` permet d'identifier un objet. Le problème est que cet opérateur englobe davantage de types qu'espéré : dates, tableaux et expressions régulières, entre autres.

L'idéal est encore d'utiliser l'opérateur `instanceof` ou la méthode `getPrototypeOf` pour valider le prototype à l'origine de la création de l'objet :

[source,javascript]
----
var Book = function Book(title){
  this.title = title;
};

var nodeBook = new Book('Node.js');
typeof nodeBook; <1>
nodeBook instanceof Book; <2>
Object.getPrototypeOf(nodeBook) === Book.prototype; <2>
----
<1> Retourne `object` ;
<2> Retourne `true`.

La méthode `defineProperty` permet de définir des comportements simples ou avancés sur n'importe quel type d'objet, y compris les prototypes :

[source,javascript]
----
var Book = function Book(title){
  this.title = title;
  this.GS1;
  this.ISBN;
}

Object.defineProperty(Book.prototype, 'EAN13', {
  get: function(){
    return this.GS1 + '-' + this.ISBN;
  },
  set: function(EAN13){
    EAN13 = EAN13.split('-');
    this.GS1 = EAN13[0];
    this.ISBN = EAN13[1];
  }
});

var cssBook = new Book('CSS maintenables');
cssBook.EAN13 = '978-2212136401';

cssBook.GS1; <1>
cssBook.ISBN; <2>
cssBook.EAN13; <3>
----
<1> Retourne `'978'`;
<2> Retourne `'2212136401'` ;
<3> Retourne `'978-2212136401'`.

ECMAScript 5 permet de définir directement ces propriétés dans la déclaration du `prototype` :

[source,javascript]
----
var Book = function Book(title){
  this.title = title;
  this.GS1;
  this.ISBN;
}

Book.prototype = {
  get EAN13(){
    return this.GS1 + '-' + this.ISBN;
  },
  set EAN13(value){
    value = value.split('-');
    this.GS1 = value[0];
    this.ISBN = value[1];
  }
};
----

Il est également plus facile d'itérer sur un objet grâce à la fonction `Object.keys` :

[source,javascript]
----
var company = {
  name: 'Eyrolles',
  address: '55, 57, 61 et 63 boulevard Saint-Germain, 75005, Paris, FRANCE',
  twitter: '@Eyrolles'
};

Object.keys(company); <1>
Object.keys(company).forEach(function(key){
  console.log(company[key]); <2>
});
----
<1> Retourne `['name', 'address', 'twitter']` ;
<2> Affiche successivement les _valeurs associées_ aux clés `name`, `address` puis `twitter`.

Il est également possible de surcharger la méthode `toString` d'un objet pour contrôler la conversion de l'objet en chaîne de caractères. +
En reprenant l'exemple précédent :

[source,javascript]
----
String(company); <1>

company.toString = function(){
  return this.name;
};

String(company); <2>
----
<1> Retourne `[object Object]` ;
<2> Retourne désormais la valeur de la propriété `name`, ici `'Eyrolles'`.

===== Function

Les fonctions permettent d'isoler des portions de code et de les rendre réutilisables.

L'opérateur `typeof` permet d'identifier une fonction :

[source,javascript]
----
typeof Date; <1>
typeof new Date(); <2>
----
<1> Retourne `'function'` ;
<2> Retourne `'object'`, car il ne s'agit plus d'une fonction mais d'une nouvelle instance construite par la fonction `Date` (le constructeur).

La méthode `bind` est extrêmement puissante car elle permet de modifier le contexte d'exécution de ladite fonction.

[source,javascript]
----
var FR = {
  capitalCity: 'Paris',
  currency: 'EUR'
};

var UK = {
  capitalCity: 'London',
  currency: 'GBP'
};

var formatCurrency = function(amount){
  return amount + ' ' + this.currency;
};

var priceInEUR = formatCurrency.bind(FR);
var priceInGBP = formatCurrency.bind(UK);

priceInEUR(100); <1>
priceInGBP(100); <2>
----
<1> Retourne `'100 EUR'` ;
<2> Retourne `'100 GBP'`.

`bind` est également capable de créer une nouvelle fonction à laquelle vous auriez appliqué partiellement des arguments :

[source,javascript]
----
var helloSomething = function(text){
  console.log('Hello ' + text);
};

var helloWorld = helloSomething.bind(null, 'World');
var helloParis = helloSomething.bind(null, 'Paris');

helloWorld(); <1>
helloParis(); <2>
helloSomething('Paris'); <2>
----
<1> Affiche `'Hello World'` ;
<2> Affiche `'Hello Paris'`.

Ce procédé est particulièrement utile pour rendre des fonctions génériques et composer des dérivées, notamment dans le cas de pagination.

Les méthodes `call` et `apply` reposent sur le même principe mais à la différente de `bind`, elles exécutent immédiatement la fonction. +
Le seul élément différenciant correspond à la syntaxe d'application des arguments :

[source,javascript]
----
var wrap = function(prefix, suffix, text){
  return prefix + text + suffix;
};

wrap.call(null, '<', '>', 'title'); <1>
wrap.apply(null, ['<', '>', 'title']); <1>
----
<1> Retourne `'<title>'`.

===== RegExp

Les expressions régulières en JavaScript permettent de pratiquer des recherches de motifs simples et complexes au sein de chaînes de caractères.
Elles sont inspirées de l'implémentation dans Perl 5.

L'opérateur `instanceof` permet d'identifier une instance d'expression régulière :

[source,javascript]
----
/Eyroll?es/g instanceof RegExp; <1>
(new RegExp('Eyroll?es', 'g')) instanceof RegExp; <1>
----
<1> Retourne `true`.

La méthode `exec` permet de capturer les occurrences d'une expression régulières au sein d'une chaîne de caractères :

[source,javascript]
----
/(.+)(Script)/.exec('ECMAScript'); <1>
----
<1> Retourne `['ECMAScript', 'ECMA', 'Script']`.

Plusieurs drapeaux peuvent être utilisés :

- `g` pour chercher dans toute la chaîne, et ne pas s'arrêter à la première occurrence trouvée ;
- `i` pour ne pas tenir compte de la casse ;
- `m` pour que les caractères `^` et `$` correspondent respectivement au début et à la fin d'une ligne au lieu du début et de la fin de la chaîne ;

[source,javascript]
----
var re;
var text = ['JavaScript', 'ECMAScript'].join("\n");

re = /^([a-z]+)(Script)/;
re.exec(text); <1>

re = /^([a-z]+)(Script)/i;
re.exec(text); <2>

re = /([a-z]+)(Script)$/i;
re.exec(text); <3>

re = /([a-z]+)(Script)$/im;
re.exec(text); <4>

re = /^([a-z]+)(Script)$/gim;
re.exec(text); <5>
re.exec(text); <6>
re.exec(text); <7>
----
<1> Retourne `null` ;
<2> Retourne `['JavaScript', 'Java', 'Script']` ;
<3> Retourne `['ECMAScript', 'ECMA', 'Script']` ;
<4> Retourne `['JavaScript', 'Java', 'Script']`, puisque `$` correspond à la fin de ligne et non la fin de chaîne ;
<5> Retourne `['JavaScript', 'Java', 'Script']` ;
<6> Retourne `['ECMAScript', 'ECMA', 'Script']` puisque le curseur a effectué la recherche après la position de la précédente occurrence ;
<7> Retourne `null` puisque le curseur a rencontré la fin de la chaîne ;

[CAUTION]
.[RemarquePreTitre]#Remarque# Gare à la réutilisation de l'objet _RegExp_ !
====
Vous l'aurez remarqué avec le drapeau `g`, le comportement de la  méthode `exec` peut renvoyer un résultat différent à chaque appel.

Il faut juste veiller à ce que ce soit un résultat escompté pour éviter tout effet de bord dans vos applications.
====

À la manière de `exec`, la méthode `test` se contente de renvoyer un booléen si un motif a été trouvé ou non :

[source,javascript]
----
/(.+)(Script)/.exec('ECMAScript'); <1>
----
<1> Retourne `true`.

===== JSON

L'introduction du support natif du parsing JSON dans ECMAScript 5 a apporté un grand confort dans la consommation de données issues d'API.
La sécurité de cette consommation a été améliorée de par sa prise en charge par les développeurs de VM ECMAScript.

La fonction `JSON.parse` tente de convertir une chaîne de texte supposée au format JSON en un objet natif :

[source,javascript]
----
var jsonContent = '{ "ECMAScript": 5.1 }';

typeof jsonContent; <1>

var content = JSON.parse(jsonContent);
content.ECMAScript; <2>

try {
  JSON.parse('{ "ECMAScript": 5.1');
}
catch (err) {
  console.log(err.message); <3>
}
----
<1> Retourne `'string'` ;
<2> Retourne `5.1` ;
<3> Affiche `Unexpected end of input` car `JSON.parse` a lancé une exception `SyntaxError`.

À l'inverse, la fonction `JSON.stringify` convertit un objet natif en chaîne de caractère au format JSON :

[source,javascript]
----
JSON.stringify({ ECMAScript: 5.1 }); <1>
JSON.stringify({ ECMAScript: 5.1 }, null, 2); <2>
----
<1> Retourne `'{"ECMAScript":5.1}'` ;
<2> Retourne `'{\n  "ECMAScript": 5.1\n}'`, le troisième argument formate proprement avec la taille d'indentation spécifiée, exprimée en nombre d'espaces par niveau de profondeur.

[TIP]
.[RemarquePreTitre]#URL# Spécification ECMAScript
====
L'ensemble de la spécification ECMAScript est disponible aux formats PDF et HTML.
Il s'agit d'une mine d'or pour comprendre les mécanismes internes du langage, les types et primitives à disposition.

- http://www.ecma-international.org/ecma-262/5.1/
====

==== Variables globales dans Node.js

En plus des primitives ECMAScript, Node introduit des variables globales supplémentaires.
Elles vous seront utiles pour faciliter le débogage ou tout simplement pour la développement et le partage de vos modules.

===== console

Toute personne ayant développé du JavaScript pour le navigateur a très certainement utilisé `console.log` pour tracer l'état d'une expression lors de l'exécution de son code.

Trois fonctions sont à garder dans un coin de la tête :

- `console.log` ;
- `console.error` ;
- `console.trace`.

`console.log` affiche une représentation textuelle d'une expression et la formate avec des motifs équivalents à la fonction C `printf()`. +
Ce contenu est envoyé vers la sortie standard, `process.stdout` :

[source,javascript]
----
console.log('ECMA%s', 'script'); <1>
----
<1> Affiche `'ECMAScript'`.

`console.error` a exactement le même comportement mais redirige vers le flux d'erreur, `process.stderr`).

`console.trace` envoie l'état de la _stack trace_ vers le flux d'erreur :

.stack-trace.js
----
$ node stack-trace.js
At level 1
At level 2
At level 3
At level 4
Trace: Level 5
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:11:13)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at Object.<anonymous> (…/examples/02-first-steps/stack-trace.js:15:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
----

Pour en savoir plus sur les méthodes fonctions disponibles, reportez-vous à la documentation en ligne du module `console` sur [URL]#http://nodejs.org/api/console.html#.

===== process

L'objet `process` correspond à l'instance de l'environnement Node en cours d'exécution.

Il permet de s'interfacer avec le système, en écoutant les évènements qu'il envoie au processus ou en écoutant les évènements que Node s'apprête à envoyer au système d'exploitation.

Le tableau `process.argv` contient le chemin du script exécuté ainsi que les différents arguments transmis à Node :

.process.js
----
node process.js <1>
node process.js argument1 "argument 2" --option1 <2>
----
<1> Retourne `[ 'node', '…/examples/chapitre-02/process.js' ]` ;
<2> Retourne `[ 'node', '…/examples/chapitre-02/process.js', 'argument1', 'argument 2', '--option1' ]`.

Il n'en faut pas davantage pour bâtir votre premier programme en ligne de commande.
Pour des besoins plus avancés, il existe un certain nombre de modules _npm_ pour exploiter les options et arguments.

[TIP]
.[RemarquePreTitre]#Remarque# Arguments internes
====
Comment faire pour passer des arguments à Node sans qu'ils soient interprétés par le script et vice-versa ?
Il suffit de les placer au bon endroit lorsque vous construisez l'appel à l'exécutable Node :

----
node <arguments node> chemin/vers/script.js <arguments script>
----

Ces arguments se retrouveront respectivement dans `process.execArgv` et `process.argv`.
====

Le deuxième ensemble d'objets à connaître est le trio `process.stdin`, `process.stdout` et `process.stderr`.
Ce sont trois flux (_Streams_) qui permettent d'accéder respectivement à l'entrée standard, à la sortie standard et à l'erreur standard.

Si ces noms vous parlent peut-être, c'est parce qu'ils sont directement inspirés de la philosophie UNIX.
Mais manipulables via l'interface JavaScript de Node.

.uppercase.js
----
echo "Entrée standard" | node uppercase.js <1>
----
<1> Affiche `ENTRÉE STANDARD`.

Le concept de _Streams_ sera développé petit à petit au fil de ce chapitre et dans le reste du livre.
C'est un concept puissant mais il y a des fonctionnalités plus simples à appréhender pour débuter.

Nous venons de voir que `process` est un objet contenant plusieurs attributes précieux.
L'héritage prototypal est utilisé pour le rendre capable d'émettre des évènements via la méthode `process.on()`.
Cette méthode est utilisée pour écouter les évènements système et permettre à nos programmes de réagir convenablement.

L'exemple suivant illustre la réaction face à un signal d'interruption (abrégé en `SIGINT`, pour _Signal Interrupt_).
Ce signal est notamment émis en pressant les touches [Menu]#CTRL# et [Menu]#C#.

.interrupt.js
----
node interrupt.js 3 <1>
^C <2>
^C <3>
^C <4>
----
<1> Affiche `Appuyer 3 fois sur CTRL+C arrêtera le programme.` ;
<2> Affiche `Nombre d'essais restants: 2` ;
<3> Affiche `Nombre d'essais restants: 1` ;
<4> Affiche `Arrêt du programme…`.

Enfin nous pourrions parler de `process.nextTick()` mais nous développerons davantage cette méthode dans _Comprendre les accès non bloquants_.

Pour en savoir plus sur les méthodes fonctions disponibles, reportez-vous à la documentation en ligne du module `process` sur [URL]#http://nodejs.org/api/process.html#.

===== module

Les modules CommonJS sont au cœur du fonctionnement de Node.
Ils permettent d'isoler, d'empaqueter et de rendre le code réutilisable.

La magie opère principalement grâce à la fonction `require` et à l'objet `module`.
Ils s'occupent respectivement de _charger_ et de _déclarer_ un module.

Techniquement parlant, un module est fichier JavaScript dont toutes les variables sont privées et inaccessibles depuis l'extérieur.
Seules les variables exposées par `module.exports` sont publiquement accessibles.

Prenons l'exemple suivant :

[source,javascript]
.currency-format.js
----
var currencies = {
  FR: {
    symbol: '€',
    decimal: ','
  }
};

function formatNumber(separator, precision, number){
  return number.toFixed(precision).replace('.', separator);
}

module.exports = function setupFormatter(currencyId){
  var currency = currencies[currencyId];
  var f = formatNumber.bind(null, currency.decimal, 2);

  return function formatCurrency(amount){
    return f(amount) + currency.symbol;
  };
};
----

Dans le précédent exemple, le module `currency-format.js` est exposé tant que fonction.
Les variables `currencies` et `formatNumber` restent encapsulées dans la portée du module.

Admettons que nous souhaitons utiliser ce module dans un programme :

[source,javascript]
.currency-main.js
----
var setupFormatter = require(./currency-format.js');
var formatCurrency = setupFormatter('FR');

console.log(typeof currencies);
console.log(formatCurrency(12));
----

La fonction `require` chargera le fichier `currency-format.js` et assignera le résultat de l'export dans la variable de votre choix, ici, `setupFormatter`.

----
node currency-main.js <1> <2>
----
<1> Affiche `undefined` ;
<2> Puis affiche `'12,00€'`.

Lors de l'exécution du précédent programme, nous avons confirmation que la variable `currencies` contenue dans le module `currency-format.js` n'est pas disponible dans le module `currency-main.js`.

Node optimise le chargement des modules en les mettant en cache.
Autrement dit et de manière générale, *un module est chargé une seule fois*.
L'unicité d'un module est assurée par son emplacement au sein du système de fichiers, en se basant sur la propriété `module.id`.

Prenons le cas de ce module :

[source,javascript]
.increment-module.js
----
var counter = 0;

console.log(module.id);

module.exports = {
  run: function(){
    return counter++;
  }
};
----

Le précédent module affichera son identifiant unique à chaque fois qu'il est _chargé_.
Dès que la méthode `run()` de l'objet exporté sera appelée, elle incrémentera la variable privée `counter` et retournera sa nouvelle valeur.

Le module suivant fait deux fois appel à `increment-module.js` et assigne le résultat dans deux variables différentes.
Ceci dans le but de vérifier le comportement du mécanisme de chargement des modules Node.

[source,javascript]
.increment-main.js
----
var incrementA = require('./increment-module.js');
var incrementB = require('./increment-module.js');

console.log(incrementA.run());
console.log(incrementB.run());
console.log(incrementA === incrementB);
----

Il ne reste plus qu'à l'exécuter pour constater ce qu'il se passe :

----
node increment-main.js <1> <2> <3> <4>
----
<1> Affiche `…/examples/chapitre-02/increment-module.js` ;
<2> Affiche `0` ;
<3> Affiche `1` ;
<4> Affiche `true`.

Le module ayant déjà été chargé une fois, Node n'ira pas charger le fichier une deuxième fois et ne créera pas de nouvelle instance de l'objet `module`.
Il se contente de *retourner la même instance de module*.

Ce comportement peut être exploité	 en tant que _design pattern_ _Singleton_, explicité plus en détail dans ce même chapitre.

Pour en savoir plus sur les méthodes fonctions disponibles, reportez-vous à la documentation en ligne des modules sur [URL]#http://nodejs.org/api/modules.html#.

===== require

TBD.

===== \__filename et __dirname

TBD.

===== setTimeout, setInterval et setImmediate

TBD.

Pour en savoir plus sur les méthodes fonctions disponibles, reportez-vous à la documentation en ligne du module `timers` sur [URL]#http://nodejs.org/api/timers.html#.

===== _

La variable globale `_` est un cas spécial.
Elle n'est prédéfinie que dans le terminal interactif (_REPL_).

Cette variable _magique_ contient systématiquement la résultat de la dernière évaluation de code.

----
$ node
> 2 + 2
4
> _ + 2
6
----

[TIP]
.[RemarquePreTitre]#Vidéo# _Introduction to Node.js_
====
Ryan Dahl, le créateur de Node, explique dans cette vidéo comment les fondamentaux de la plate-forme ont influencé sa conception et façonné son architecture.

- http://www.youtube.com/watch?v=M-sc73Y-zQA
====

